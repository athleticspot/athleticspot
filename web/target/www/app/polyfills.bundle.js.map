{"version":3,"sources":["webpack:///app/polyfills.bundle.js","webpack:///./~/reflect-metadata/Reflect.ts","webpack:///./~/zone.js/dist/zone.js","webpack:///./src/main/webapp/app/polyfills.ts","webpack:///./src/main/webapp/manifest.webapp","webpack:///external \"vendor\"","webpack:///delegated ./node_modules/webpack/buildin/global.js from dll-reference vendor","webpack:///delegated ./node_modules/process/browser.js from dll-reference vendor","webpack:///delegated ./node_modules/css-loader/lib/css-base.js from dll-reference vendor"],"names":["webpackJsonp","./node_modules/reflect-metadata/Reflect.ts","module","exports","__webpack_require__","process","global","Reflect","decorate","decorators","target","propertyKey","attributes","IsUndefined","IsArray","TypeError","IsConstructor","DecorateConstructor","IsObject","IsNull","undefined","ToPropertyKey","DecorateProperty","metadata","metadataKey","metadataValue","decorator","IsPropertyKey","OrdinaryDefineOwnMetadata","defineMetadata","hasMetadata","OrdinaryHasMetadata","hasOwnMetadata","OrdinaryHasOwnMetadata","getMetadata","OrdinaryGetMetadata","getOwnMetadata","OrdinaryGetOwnMetadata","getMetadataKeys","OrdinaryMetadataKeys","getOwnMetadataKeys","OrdinaryOwnMetadataKeys","deleteMetadata","metadataMap","GetOrCreateMetadataMap","delete","size","targetMetadata","Metadata","get","i","length","decorated","descriptor","O","P","Create","_Map","set","MetadataKey","parent","OrdinaryGetPrototypeOf","ToBoolean","has","MetadataValue","ownKeys","parentKeys","_Set","keys","_i","ownKeys_1","key","hasKey","add","push","_a","parentKeys_1","keysObj","iterator","GetIterator","k","next","IteratorStep","nextValue","IteratorValue","e","IteratorClose","Type","x","IsSymbol","ToPrimitive","input","PreferredType","hint","exoticToPrim","GetMethod","toPrimitiveSymbol","result","call","OrdinaryToPrimitive","toString_1","toString","IsCallable","valueOf","toString_2","argument","ToString","Array","isArray","Object","prototype","V","func","obj","method","iteratorSymbol","iterResult","value","done","f","proto","getPrototypeOf","functionPrototype","prototypeProto","constructor","MakeDictionary","__","HashMap","hasOwn","hasOwnProperty","supportsSymbol","Symbol","toPrimitive","supportsCreate","create","supportsProto","__proto__","downLevel","map","Function","usePolyfill","env","Map","entries","getKey","_","getValue","getEntry","cacheSentinel","arraySentinel","MapIterator","values","selector","this","_index","_keys","_values","_selector","index","throw","error","return","_cacheKey","_cacheIndex","defineProperty","enumerable","configurable","_find","clear","insert","indexOf","Set","_map","_WeakMap","WeakMap","CreateUniqueKey","CreateUUID","GetOrCreateWeakMapTable","rootKey","FillRandomBytes","buffer","Math","random","GenRandomBytes","Uint8Array","crypto","getRandomValues","msCrypto","data","UUID_SIZE","offset","byte","toLowerCase","_key","table","__global","p","self","./node_modules/zone.js/dist/zone.js","factory","bindArguments","args","source","Zone","current","wrap","patchPrototype","fnNames","name_1","delegate","patched","apply","arguments","attachOriginToPatched","patchProperty","prop","desc","getOwnPropertyDescriptor","writable","originalDescGet","eventName","substr","_prop","zoneSymbol","newValue","_global","previousValue","removeEventListener","wrapFn","event","preventDefault","addEventListener","removeAttribute","patchOnProperties","properties","onProperties","j","compareEventListenerOptions","left","right","capture","findExistingRegisteredTask","handler","name","options","remove","eventTasks","EVENT_TASKS","eventTask","listener","splice","attachRegisteredEvent","isPrepend","unshift","makeZoneAwareAddListener","addFnName","removeFnName","useCapturingParam","allowDuplicates","metaCreator","scheduleEventListener","meta","invokeAddFunc","addFnSymbol","cancelEventListener","invoke","invokeRemoveFunc","removeFnSymbol","defaultListenerMetaCreator","defaultUseCapturing","handleEvent","validZoneHandler","crossContext","zone","scheduleEventTask","makeZoneAwareRemoveListener","fnName","symbol","cancelTask","patchEventTargetMethods","ADD_EVENT_LISTENER","REMOVE_EVENT_LISTENER","patchMethod","patchClass","className","OriginalClass","a","originalInstanceKey","Error","instance","fn","patchFn","delegateName","patchDelegate_1","findEventTask","evtName","original","patchTimer","window","setName","cancelName","nameSuffix","scheduleTask","task","timer","handleId","tasksByHandleId","setNative","clearTask","clearNative","isPeriodic","delay","scheduleMacroTask","handle","ref","unref","bind","type","state","cancelFn","runCount","propertyPatch","isUnconfigurable","originalConfigurableFlag","rewriteDescriptor","_tryDefineProperty","defineProperties","props","forEach","isFrozen","_create","_getOwnPropertyDescriptor","_redefineProperty","unconfigurablesKey","_defineProperty","descJson","JSON","stringify","console","log","eventTargetPatch","apis","WTF_ISSUE_555","split","v","concat","NO_EVENT_TARGET","EVENT_TARGET","WS","WebSocket","EventTarget","b","proxySocket","socket","onmessageDesc","propName","propertyDescriptorPatch","isNode","isMix","supportsWebSocket","canPatchViaPropertyDescriptor","isBrowser","eventNames","Document","Element","HTMLElement","HTMLMediaElement","mediaElementEventNames","HTMLFrameSetElement","windowEventNames","frameSetEventNames","HTMLBodyElement","HTMLFrameElement","frameEventNames","HTMLIFrameElement","HTMLMarqueeElement_1","marqueeEventNames","XMLHttpRequest","XMLHttpRequestEventNames","XMLHttpRequestEventTarget","IDBIndex","IDBIndexEventNames","IDBRequest","IDBOpenDBRequest","IDBDatabase","IDBTransaction","IDBCursor","websocketEventNames","patchViaCapturingAllTheEvents","xhrDesc","req","onreadystatechange","detectFunc","property","onproperty","bound","elt","unboundKey","parentElement","registerElementPatch","document","_registerElement","registerElement","callbacks","opts","callback","mark","performance","performanceMeasure","label","scheduleMicroTask","_numberOfNestedTaskFrames","_microTaskQueue","symbolPromise","resolve","symbolThen","drainMicroTaskQueue","symbolSetTimeout","_isDrainingMicrotaskQueue","queue","runTask","_api","onUnhandledError","__symbol__","microtaskDrainDone","noop","zoneSpec","_properties","_parent","_name","_zoneDelegate","ZoneDelegate","assertZonePatched","patches","_currentZoneFrame","_currentTask","__load_patch","perfName","getZoneWith","fork","_callback","intercept","runGuarded","run","applyThis","applyArgs","handleError","NO_ZONE","notScheduled","reEntryGuard","running","_transitionTo","scheduled","previousTask","macroTask","invokeTask","unknown","_updateTaskCount","newZone","scheduling","zoneDelegates","_zoneDelegates","_zone","err","customSchedule","ZoneTask","microTask","customCancel","canceling","count","DELEGATE_ZS","onHasTask","hasTaskState","hasTask","onScheduleTask","onInvokeTask","onCancelTask","parentDelegate","_taskCounts","_parentDelegate","_forkZS","onFork","_forkDlgt","_forkCurrZone","_interceptZS","onIntercept","_interceptDlgt","_interceptCurrZone","_invokeZS","onInvoke","_invokeDlgt","_invokeCurrZone","_handleErrorZS","onHandleError","_handleErrorDlgt","_handleErrorCurrZone","_scheduleTaskZS","_scheduleTaskDlgt","_scheduleTaskCurrZone","_invokeTaskZS","_invokeTaskDlgt","_invokeTaskCurrZone","_cancelTaskZS","_cancelTaskDlgt","_cancelTaskCurrZone","_hasTaskZS","_hasTaskDlgt","_hasTaskDlgtOwner","_hasTaskCurrZone","zoneSpecHasTask","parentHasTask","targetZone","returnTask","scheduleFn","isEmpty","counts","prev","change","_state","cancelScheduleRequest","toState","fromState1","fromState2","toJSON","currentZoneFrame","showUncaughtError","api","handleUnhandledRejection","isThenable","then","forwardResolution","forwardRejection","rejection","ZoneAwarePromise","reject","makeResolver","promise","resolvePromise","onceWrapper","once","symbolState","UNRESOLVED","REJECTED","symbolValue","clearRejectedNoCatch","currentTask","scheduleResolveOrReject","REJECTED_NO_CATCH","stack","error_1","_uncaughtPromiseErrors","chainPromise","onFulfilled","onRejected","patchThen","Ctor","originalThen","onResolve","onReject","_this","symbolThenPatched","message","uncaughtPromiseError","shift","RESOLVED","wasCalled","wrappedFunction","executor","race","res","rej","values_1","all","resolvedValues","values_2","catch","NativePromise","fetch_1","resultPromise","ctor","Promise","n","isWebWorker","WorkerGlobalScope","originalFunctionToString","nativePromise","nativeError","originalObjectToString","globalEventHandlersEventNames","documentEventNames","htmlElementEventNames","ieElementEventNames","webglEventNames","formEventNames","detailEventNames","blockingMethods","s","findPendingTask","XHR_TASK","XHR_SCHEDULED","XHR_LISTENER","newListener","readyState","DONE","aborted","sendNative","placeholderCallback","abortNative","openNative","XHR_SYNC","geolocation","findPromiseRejectionHandler","PromiseRejectionEvent","evt","reason","./src/main/webapp/app/polyfills.ts","./src/main/webapp/manifest.webapp","1","vendor","16","24","8"],"mappings":"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ACA,aACA,YACA,WACA,YACA,UACA,aACA,QACA,OACA,UACA,gBACA,cACA,eACA,eACA,oBACA,uBACA,4BACA,mBACA,sBACA,yBACA,cACA,WACA,cACA,YACA,WACA,aACA,QACA,SACA,SACA,SACA,UACA,SACA,kBACA,cACA,OACA,OACA,UACA,SACA,UACA,aACA,eACA,cACA,YACA,aACA,mBACA,gBACA,UACA,SAEAC,GACA,iFACA,sFACA,qFAEA5N,GACA,4BACA,aACA,aACA,eACA,sBACA,cACA,eACA,cACA,eACA,oBACA,4BACA,kBACA,aACA,iBACA,UACA,iBACA,UACA,SACA,QACA,WACA,WACA,WACA,mBACA,UACA,qBACA,SACA,gBACA,oBACA,wBACA,0BAEA6N,GACA,kFACA,iFACA,yEAEA/N,GAAA,+EACAgO,GACA,WACA,cACA,cACA,iBACA,mBACA,kBACA,eACA,aACA,gBACA,gBACA,iBACA,kBACA,cACA,eACA,iBACA,cACA,OACA,UACA,YACA,iBACA,YACA,cACA,WACA,UACA,aACA,eACA,UACA,0BACA,aACA,OACA,gBACA,6BACA,kBACA,qBACA,eACA,gBACA,iBACA,eACA,sBACA,iBACA,uBACA,kBACA,gBACA,iBACA,iBACA,iBACA,gBACA,eACA,gBACA,cACA,aACA,gCACA,mBACA,OACA,iBAEAC,GAAA,uEACAC,GAAA,oCACAC,GAAA,UACA7N,IAAA,QACAH,IAAA,iDACAM,IAAA,2BACAE,IACA,6EACA,oBAEAG,IAAA,wFACAM,IAAA,kCACAzB,GAAAkO,EAAAnP,OAAAuP,EAAAC,EAAAC,EAAAL,EAAA5N,EAAA6N,EAAAC,GAwGAlM,GAAA9K,EAAA;;;;;;;AA2EApB,KAAAyO,aAAA,kBAAA9a,EAAAqM,EAAAmU,GAGArO,EAAAnS,EAFA,MACA,QACA,WACAmS,EAAAnS,EAHA,MACA,QAEA,YACAmS,EAAAnS,EAJA,MACA,QAGA,aACAmS,EAAAnS,EAAA,qCACAmS,EAAAnS,EAAA,2CACAmS,EAAAnS,EAAA,mDAEAqM,KAAAyO,aAAA,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","file":"app/polyfills.bundle.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ \"./node_modules/reflect-metadata/Reflect.ts\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process, global) {/*! *****************************************************************************\r\nCopyright (C) Microsoft. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\nvar Reflect;\r\n(function (Reflect) {\r\n    \"use strict\";\r\n    var hasOwn = Object.prototype.hasOwnProperty;\r\n    // feature test for Symbol support\r\n    var supportsSymbol = typeof Symbol === \"function\";\r\n    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== \"undefined\" ? Symbol.toPrimitive : \"@@toPrimitive\";\r\n    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\r\n    var HashMap;\r\n    (function (HashMap) {\r\n        var supportsCreate = typeof Object.create === \"function\"; // feature test for Object.create support\r\n        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support\r\n        var downLevel = !supportsCreate && !supportsProto;\r\n        // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\r\n        HashMap.create = supportsCreate\r\n            ? function () { return MakeDictionary(Object.create(null)); }\r\n            : supportsProto\r\n                ? function () { return MakeDictionary({ __proto__: null }); }\r\n                : function () { return MakeDictionary({}); };\r\n        HashMap.has = downLevel\r\n            ? function (map, key) { return hasOwn.call(map, key); }\r\n            : function (map, key) { return key in map; };\r\n        HashMap.get = downLevel\r\n            ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }\r\n            : function (map, key) { return map[key]; };\r\n    })(HashMap || (HashMap = {}));\r\n    // Load global or shim versions of Map, Set, and WeakMap\r\n    var functionPrototype = Object.getPrototypeOf(Function);\r\n    var usePolyfill = typeof process === \"object\" && process.env && process.env[\"REFLECT_METADATA_USE_MAP_POLYFILL\"] === \"true\";\r\n    var _Map = !usePolyfill && typeof Map === \"function\" && typeof Map.prototype.entries === \"function\" ? Map : CreateMapPolyfill();\r\n    var _Set = !usePolyfill && typeof Set === \"function\" && typeof Set.prototype.entries === \"function\" ? Set : CreateSetPolyfill();\r\n    var _WeakMap = !usePolyfill && typeof WeakMap === \"function\" ? WeakMap : CreateWeakMapPolyfill();\r\n    // [[Metadata]] internal slot\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots\r\n    var Metadata = new _WeakMap();\r\n    /**\r\n      * Applies a set of decorators to a property of a target object.\r\n      * @param decorators An array of decorators.\r\n      * @param target The target object.\r\n      * @param propertyKey (Optional) The property key to decorate.\r\n      * @param attributes (Optional) The property descriptor for the target key.\r\n      * @remarks Decorators are applied in reverse order.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     Example = Reflect.decorate(decoratorsArray, Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     Object.defineProperty(Example, \"staticMethod\",\r\n      *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\r\n      *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\r\n      *\r\n      *     // method (on prototype)\r\n      *     Object.defineProperty(Example.prototype, \"method\",\r\n      *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\r\n      *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\r\n      *\r\n      */\r\n    function decorate(decorators, target, propertyKey, attributes) {\r\n        if (!IsUndefined(propertyKey)) {\r\n            if (!IsArray(decorators))\r\n                throw new TypeError();\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))\r\n                throw new TypeError();\r\n            if (IsNull(attributes))\r\n                attributes = undefined;\r\n            propertyKey = ToPropertyKey(propertyKey);\r\n            return DecorateProperty(decorators, target, propertyKey, attributes);\r\n        }\r\n        else {\r\n            if (!IsArray(decorators))\r\n                throw new TypeError();\r\n            if (!IsConstructor(target))\r\n                throw new TypeError();\r\n            return DecorateConstructor(decorators, target);\r\n        }\r\n    }\r\n    Reflect.decorate = decorate;\r\n    // 4.1.2 Reflect.metadata(metadataKey, metadataValue)\r\n    // https://rbuckton.github.io/reflect-metadata/#reflect.metadata\r\n    /**\r\n      * A default metadata decorator factory that can be used on a class, class member, or parameter.\r\n      * @param metadataKey The key for the metadata entry.\r\n      * @param metadataValue The value for the metadata entry.\r\n      * @returns A decorator function.\r\n      * @remarks\r\n      * If `metadataKey` is already defined for the target and target key, the\r\n      * metadataValue for that key will be overwritten.\r\n      * @example\r\n      *\r\n      *     // constructor\r\n      *     @Reflect.metadata(key, value)\r\n      *     class Example {\r\n      *     }\r\n      *\r\n      *     // property (on constructor, TypeScript only)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         static staticProperty;\r\n      *     }\r\n      *\r\n      *     // property (on prototype, TypeScript only)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         property;\r\n      *     }\r\n      *\r\n      *     // method (on constructor)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         static staticMethod() { }\r\n      *     }\r\n      *\r\n      *     // method (on prototype)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         method() { }\r\n      *     }\r\n      *\r\n      */\r\n    function metadata(metadataKey, metadataValue) {\r\n        function decorator(target, propertyKey) {\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))\r\n                throw new TypeError();\r\n            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\r\n        }\r\n        return decorator;\r\n    }\r\n    Reflect.metadata = metadata;\r\n    /**\r\n      * Define a unique metadata entry on the target.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param metadataValue A value that contains attached metadata.\r\n      * @param target The target object on which to define metadata.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\r\n      *\r\n      *     // decorator factory as metadata-producing annotation.\r\n      *     function MyAnnotation(options): Decorator {\r\n      *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\r\n      *     }\r\n      *\r\n      */\r\n    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(propertyKey))\r\n            propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\r\n    }\r\n    Reflect.defineMetadata = defineMetadata;\r\n    /**\r\n      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function hasMetadata(metadataKey, target, propertyKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(propertyKey))\r\n            propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryHasMetadata(metadataKey, target, propertyKey);\r\n    }\r\n    Reflect.hasMetadata = hasMetadata;\r\n    /**\r\n      * Gets a value indicating whether the target object has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function hasOwnMetadata(metadataKey, target, propertyKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(propertyKey))\r\n            propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);\r\n    }\r\n    Reflect.hasOwnMetadata = hasOwnMetadata;\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function getMetadata(metadataKey, target, propertyKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(propertyKey))\r\n            propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryGetMetadata(metadataKey, target, propertyKey);\r\n    }\r\n    Reflect.getMetadata = getMetadata;\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function getOwnMetadata(metadataKey, target, propertyKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(propertyKey))\r\n            propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);\r\n    }\r\n    Reflect.getOwnMetadata = getOwnMetadata;\r\n    /**\r\n      * Gets the metadata keys defined on the target object or its prototype chain.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getMetadataKeys(Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function getMetadataKeys(target, propertyKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(propertyKey))\r\n            propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryMetadataKeys(target, propertyKey);\r\n    }\r\n    Reflect.getMetadataKeys = getMetadataKeys;\r\n    /**\r\n      * Gets the unique metadata keys defined on the target object.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getOwnMetadataKeys(Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function getOwnMetadataKeys(target, propertyKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(propertyKey))\r\n            propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryOwnMetadataKeys(target, propertyKey);\r\n    }\r\n    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;\r\n    /**\r\n      * Deletes the metadata entry from the target object with the provided key.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata entry was found and deleted; otherwise, false.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function deleteMetadata(metadataKey, target, propertyKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(propertyKey))\r\n            propertyKey = ToPropertyKey(propertyKey);\r\n        var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);\r\n        if (IsUndefined(metadataMap))\r\n            return false;\r\n        if (!metadataMap.delete(metadataKey))\r\n            return false;\r\n        if (metadataMap.size > 0)\r\n            return true;\r\n        var targetMetadata = Metadata.get(target);\r\n        targetMetadata.delete(propertyKey);\r\n        if (targetMetadata.size > 0)\r\n            return true;\r\n        Metadata.delete(target);\r\n        return true;\r\n    }\r\n    Reflect.deleteMetadata = deleteMetadata;\r\n    function DecorateConstructor(decorators, target) {\r\n        for (var i = decorators.length - 1; i >= 0; --i) {\r\n            var decorator = decorators[i];\r\n            var decorated = decorator(target);\r\n            if (!IsUndefined(decorated) && !IsNull(decorated)) {\r\n                if (!IsConstructor(decorated))\r\n                    throw new TypeError();\r\n                target = decorated;\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    function DecorateProperty(decorators, target, propertyKey, descriptor) {\r\n        for (var i = decorators.length - 1; i >= 0; --i) {\r\n            var decorator = decorators[i];\r\n            var decorated = decorator(target, propertyKey, descriptor);\r\n            if (!IsUndefined(decorated) && !IsNull(decorated)) {\r\n                if (!IsObject(decorated))\r\n                    throw new TypeError();\r\n                descriptor = decorated;\r\n            }\r\n        }\r\n        return descriptor;\r\n    }\r\n    function GetOrCreateMetadataMap(O, P, Create) {\r\n        var targetMetadata = Metadata.get(O);\r\n        if (IsUndefined(targetMetadata)) {\r\n            if (!Create)\r\n                return undefined;\r\n            targetMetadata = new _Map();\r\n            Metadata.set(O, targetMetadata);\r\n        }\r\n        var metadataMap = targetMetadata.get(P);\r\n        if (IsUndefined(metadataMap)) {\r\n            if (!Create)\r\n                return undefined;\r\n            metadataMap = new _Map();\r\n            targetMetadata.set(P, metadataMap);\r\n        }\r\n        return metadataMap;\r\n    }\r\n    // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata\r\n    function OrdinaryHasMetadata(MetadataKey, O, P) {\r\n        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n        if (hasOwn)\r\n            return true;\r\n        var parent = OrdinaryGetPrototypeOf(O);\r\n        if (!IsNull(parent))\r\n            return OrdinaryHasMetadata(MetadataKey, parent, P);\r\n        return false;\r\n    }\r\n    // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\r\n    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\r\n        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\r\n        if (IsUndefined(metadataMap))\r\n            return false;\r\n        return ToBoolean(metadataMap.has(MetadataKey));\r\n    }\r\n    // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata\r\n    function OrdinaryGetMetadata(MetadataKey, O, P) {\r\n        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n        if (hasOwn)\r\n            return OrdinaryGetOwnMetadata(MetadataKey, O, P);\r\n        var parent = OrdinaryGetPrototypeOf(O);\r\n        if (!IsNull(parent))\r\n            return OrdinaryGetMetadata(MetadataKey, parent, P);\r\n        return undefined;\r\n    }\r\n    // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\r\n    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\r\n        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\r\n        if (IsUndefined(metadataMap))\r\n            return undefined;\r\n        return metadataMap.get(MetadataKey);\r\n    }\r\n    // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\r\n    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\r\n        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);\r\n        metadataMap.set(MetadataKey, MetadataValue);\r\n    }\r\n    // 3.1.6.1 OrdinaryMetadataKeys(O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys\r\n    function OrdinaryMetadataKeys(O, P) {\r\n        var ownKeys = OrdinaryOwnMetadataKeys(O, P);\r\n        var parent = OrdinaryGetPrototypeOf(O);\r\n        if (parent === null)\r\n            return ownKeys;\r\n        var parentKeys = OrdinaryMetadataKeys(parent, P);\r\n        if (parentKeys.length <= 0)\r\n            return ownKeys;\r\n        if (ownKeys.length <= 0)\r\n            return parentKeys;\r\n        var set = new _Set();\r\n        var keys = [];\r\n        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {\r\n            var key = ownKeys_1[_i];\r\n            var hasKey = set.has(key);\r\n            if (!hasKey) {\r\n                set.add(key);\r\n                keys.push(key);\r\n            }\r\n        }\r\n        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {\r\n            var key = parentKeys_1[_a];\r\n            var hasKey = set.has(key);\r\n            if (!hasKey) {\r\n                set.add(key);\r\n                keys.push(key);\r\n            }\r\n        }\r\n        return keys;\r\n    }\r\n    // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\r\n    function OrdinaryOwnMetadataKeys(O, P) {\r\n        var keys = [];\r\n        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\r\n        if (IsUndefined(metadataMap))\r\n            return keys;\r\n        var keysObj = metadataMap.keys();\r\n        var iterator = GetIterator(keysObj);\r\n        var k = 0;\r\n        while (true) {\r\n            var next = IteratorStep(iterator);\r\n            if (!next) {\r\n                keys.length = k;\r\n                return keys;\r\n            }\r\n            var nextValue = IteratorValue(next);\r\n            try {\r\n                keys[k] = nextValue;\r\n            }\r\n            catch (e) {\r\n                try {\r\n                    IteratorClose(iterator);\r\n                }\r\n                finally {\r\n                    throw e;\r\n                }\r\n            }\r\n            k++;\r\n        }\r\n    }\r\n    // 6 ECMAScript Data Typ0es and Values\r\n    // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values\r\n    function Type(x) {\r\n        if (x === null)\r\n            return 1 /* Null */;\r\n        switch (typeof x) {\r\n            case \"undefined\": return 0 /* Undefined */;\r\n            case \"boolean\": return 2 /* Boolean */;\r\n            case \"string\": return 3 /* String */;\r\n            case \"symbol\": return 4 /* Symbol */;\r\n            case \"number\": return 5 /* Number */;\r\n            case \"object\": return x === null ? 1 /* Null */ : 6 /* Object */;\r\n            default: return 6 /* Object */;\r\n        }\r\n    }\r\n    // 6.1.1 The Undefined Type\r\n    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type\r\n    function IsUndefined(x) {\r\n        return x === undefined;\r\n    }\r\n    // 6.1.2 The Null Type\r\n    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type\r\n    function IsNull(x) {\r\n        return x === null;\r\n    }\r\n    // 6.1.5 The Symbol Type\r\n    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type\r\n    function IsSymbol(x) {\r\n        return typeof x === \"symbol\";\r\n    }\r\n    // 6.1.7 The Object Type\r\n    // https://tc39.github.io/ecma262/#sec-object-type\r\n    function IsObject(x) {\r\n        return typeof x === \"object\" ? x !== null : typeof x === \"function\";\r\n    }\r\n    // 7.1 Type Conversion\r\n    // https://tc39.github.io/ecma262/#sec-type-conversion\r\n    // 7.1.1 ToPrimitive(input [, PreferredType])\r\n    // https://tc39.github.io/ecma262/#sec-toprimitive\r\n    function ToPrimitive(input, PreferredType) {\r\n        switch (Type(input)) {\r\n            case 0 /* Undefined */: return input;\r\n            case 1 /* Null */: return input;\r\n            case 2 /* Boolean */: return input;\r\n            case 3 /* String */: return input;\r\n            case 4 /* Symbol */: return input;\r\n            case 5 /* Number */: return input;\r\n        }\r\n        var hint = PreferredType === 3 /* String */ ? \"string\" : PreferredType === 5 /* Number */ ? \"number\" : \"default\";\r\n        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);\r\n        if (exoticToPrim !== undefined) {\r\n            var result = exoticToPrim.call(input, hint);\r\n            if (IsObject(result))\r\n                throw new TypeError();\r\n            return result;\r\n        }\r\n        return OrdinaryToPrimitive(input, hint === \"default\" ? \"number\" : hint);\r\n    }\r\n    // 7.1.1.1 OrdinaryToPrimitive(O, hint)\r\n    // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive\r\n    function OrdinaryToPrimitive(O, hint) {\r\n        if (hint === \"string\") {\r\n            var toString_1 = O.toString;\r\n            if (IsCallable(toString_1)) {\r\n                var result = toString_1.call(O);\r\n                if (!IsObject(result))\r\n                    return result;\r\n            }\r\n            var valueOf = O.valueOf;\r\n            if (IsCallable(valueOf)) {\r\n                var result = valueOf.call(O);\r\n                if (!IsObject(result))\r\n                    return result;\r\n            }\r\n        }\r\n        else {\r\n            var valueOf = O.valueOf;\r\n            if (IsCallable(valueOf)) {\r\n                var result = valueOf.call(O);\r\n                if (!IsObject(result))\r\n                    return result;\r\n            }\r\n            var toString_2 = O.toString;\r\n            if (IsCallable(toString_2)) {\r\n                var result = toString_2.call(O);\r\n                if (!IsObject(result))\r\n                    return result;\r\n            }\r\n        }\r\n        throw new TypeError();\r\n    }\r\n    // 7.1.2 ToBoolean(argument)\r\n    // https://tc39.github.io/ecma262/2016/#sec-toboolean\r\n    function ToBoolean(argument) {\r\n        return !!argument;\r\n    }\r\n    // 7.1.12 ToString(argument)\r\n    // https://tc39.github.io/ecma262/#sec-tostring\r\n    function ToString(argument) {\r\n        return \"\" + argument;\r\n    }\r\n    // 7.1.14 ToPropertyKey(argument)\r\n    // https://tc39.github.io/ecma262/#sec-topropertykey\r\n    function ToPropertyKey(argument) {\r\n        var key = ToPrimitive(argument, 3 /* String */);\r\n        if (IsSymbol(key))\r\n            return key;\r\n        return ToString(key);\r\n    }\r\n    // 7.2 Testing and Comparison Operations\r\n    // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations\r\n    // 7.2.2 IsArray(argument)\r\n    // https://tc39.github.io/ecma262/#sec-isarray\r\n    function IsArray(argument) {\r\n        return Array.isArray\r\n            ? Array.isArray(argument)\r\n            : argument instanceof Object\r\n                ? argument instanceof Array\r\n                : Object.prototype.toString.call(argument) === \"[object Array]\";\r\n    }\r\n    // 7.2.3 IsCallable(argument)\r\n    // https://tc39.github.io/ecma262/#sec-iscallable\r\n    function IsCallable(argument) {\r\n        // NOTE: This is an approximation as we cannot check for [[Call]] internal method.\r\n        return typeof argument === \"function\";\r\n    }\r\n    // 7.2.4 IsConstructor(argument)\r\n    // https://tc39.github.io/ecma262/#sec-isconstructor\r\n    function IsConstructor(argument) {\r\n        // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.\r\n        return typeof argument === \"function\";\r\n    }\r\n    // 7.2.7 IsPropertyKey(argument)\r\n    // https://tc39.github.io/ecma262/#sec-ispropertykey\r\n    function IsPropertyKey(argument) {\r\n        switch (Type(argument)) {\r\n            case 3 /* String */: return true;\r\n            case 4 /* Symbol */: return true;\r\n            default: return false;\r\n        }\r\n    }\r\n    // 7.3 Operations on Objects\r\n    // https://tc39.github.io/ecma262/#sec-operations-on-objects\r\n    // 7.3.9 GetMethod(V, P)\r\n    // https://tc39.github.io/ecma262/#sec-getmethod\r\n    function GetMethod(V, P) {\r\n        var func = V[P];\r\n        if (func === undefined || func === null)\r\n            return undefined;\r\n        if (!IsCallable(func))\r\n            throw new TypeError();\r\n        return func;\r\n    }\r\n    // 7.4 Operations on Iterator Objects\r\n    // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects\r\n    function GetIterator(obj) {\r\n        var method = GetMethod(obj, iteratorSymbol);\r\n        if (!IsCallable(method))\r\n            throw new TypeError(); // from Call\r\n        var iterator = method.call(obj);\r\n        if (!IsObject(iterator))\r\n            throw new TypeError();\r\n        return iterator;\r\n    }\r\n    // 7.4.4 IteratorValue(iterResult)\r\n    // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue\r\n    function IteratorValue(iterResult) {\r\n        return iterResult.value;\r\n    }\r\n    // 7.4.5 IteratorStep(iterator)\r\n    // https://tc39.github.io/ecma262/#sec-iteratorstep\r\n    function IteratorStep(iterator) {\r\n        var result = iterator.next();\r\n        return result.done ? false : result;\r\n    }\r\n    // 7.4.6 IteratorClose(iterator, completion)\r\n    // https://tc39.github.io/ecma262/#sec-iteratorclose\r\n    function IteratorClose(iterator) {\r\n        var f = iterator[\"return\"];\r\n        if (f)\r\n            f.call(iterator);\r\n    }\r\n    // 9.1 Ordinary Object Internal Methods and Internal Slots\r\n    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots\r\n    // 9.1.1.1 OrdinaryGetPrototypeOf(O)\r\n    // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof\r\n    function OrdinaryGetPrototypeOf(O) {\r\n        var proto = Object.getPrototypeOf(O);\r\n        if (typeof O !== \"function\" || O === functionPrototype)\r\n            return proto;\r\n        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.\r\n        // Try to determine the superclass constructor. Compatible implementations\r\n        // must either set __proto__ on a subclass constructor to the superclass constructor,\r\n        // or ensure each class has a valid `constructor` property on its prototype that\r\n        // points back to the constructor.\r\n        // If this is not the same as Function.[[Prototype]], then this is definately inherited.\r\n        // This is the case when in ES6 or when using __proto__ in a compatible browser.\r\n        if (proto !== functionPrototype)\r\n            return proto;\r\n        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\r\n        var prototype = O.prototype;\r\n        var prototypeProto = prototype && Object.getPrototypeOf(prototype);\r\n        if (prototypeProto == null || prototypeProto === Object.prototype)\r\n            return proto;\r\n        // If the constructor was not a function, then we cannot determine the heritage.\r\n        var constructor = prototypeProto.constructor;\r\n        if (typeof constructor !== \"function\")\r\n            return proto;\r\n        // If we have some kind of self-reference, then we cannot determine the heritage.\r\n        if (constructor === O)\r\n            return proto;\r\n        // we have a pretty good guess at the heritage.\r\n        return constructor;\r\n    }\r\n    // naive Map shim\r\n    function CreateMapPolyfill() {\r\n        var cacheSentinel = {};\r\n        var arraySentinel = [];\r\n        var MapIterator = (function () {\r\n            function MapIterator(keys, values, selector) {\r\n                this._index = 0;\r\n                this._keys = keys;\r\n                this._values = values;\r\n                this._selector = selector;\r\n            }\r\n            MapIterator.prototype[\"@@iterator\"] = function () { return this; };\r\n            MapIterator.prototype[iteratorSymbol] = function () { return this; };\r\n            MapIterator.prototype.next = function () {\r\n                var index = this._index;\r\n                if (index >= 0 && index < this._keys.length) {\r\n                    var result = this._selector(this._keys[index], this._values[index]);\r\n                    if (index + 1 >= this._keys.length) {\r\n                        this._index = -1;\r\n                        this._keys = arraySentinel;\r\n                        this._values = arraySentinel;\r\n                    }\r\n                    else {\r\n                        this._index++;\r\n                    }\r\n                    return { value: result, done: false };\r\n                }\r\n                return { value: undefined, done: true };\r\n            };\r\n            MapIterator.prototype.throw = function (error) {\r\n                if (this._index >= 0) {\r\n                    this._index = -1;\r\n                    this._keys = arraySentinel;\r\n                    this._values = arraySentinel;\r\n                }\r\n                throw error;\r\n            };\r\n            MapIterator.prototype.return = function (value) {\r\n                if (this._index >= 0) {\r\n                    this._index = -1;\r\n                    this._keys = arraySentinel;\r\n                    this._values = arraySentinel;\r\n                }\r\n                return { value: value, done: true };\r\n            };\r\n            return MapIterator;\r\n        }());\r\n        return (function () {\r\n            function Map() {\r\n                this._keys = [];\r\n                this._values = [];\r\n                this._cacheKey = cacheSentinel;\r\n                this._cacheIndex = -2;\r\n            }\r\n            Object.defineProperty(Map.prototype, \"size\", {\r\n                get: function () { return this._keys.length; },\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n            Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };\r\n            Map.prototype.get = function (key) {\r\n                var index = this._find(key, /*insert*/ false);\r\n                return index >= 0 ? this._values[index] : undefined;\r\n            };\r\n            Map.prototype.set = function (key, value) {\r\n                var index = this._find(key, /*insert*/ true);\r\n                this._values[index] = value;\r\n                return this;\r\n            };\r\n            Map.prototype.delete = function (key) {\r\n                var index = this._find(key, /*insert*/ false);\r\n                if (index >= 0) {\r\n                    var size = this._keys.length;\r\n                    for (var i = index + 1; i < size; i++) {\r\n                        this._keys[i - 1] = this._keys[i];\r\n                        this._values[i - 1] = this._values[i];\r\n                    }\r\n                    this._keys.length--;\r\n                    this._values.length--;\r\n                    if (key === this._cacheKey) {\r\n                        this._cacheKey = cacheSentinel;\r\n                        this._cacheIndex = -2;\r\n                    }\r\n                    return true;\r\n                }\r\n                return false;\r\n            };\r\n            Map.prototype.clear = function () {\r\n                this._keys.length = 0;\r\n                this._values.length = 0;\r\n                this._cacheKey = cacheSentinel;\r\n                this._cacheIndex = -2;\r\n            };\r\n            Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };\r\n            Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };\r\n            Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };\r\n            Map.prototype[\"@@iterator\"] = function () { return this.entries(); };\r\n            Map.prototype[iteratorSymbol] = function () { return this.entries(); };\r\n            Map.prototype._find = function (key, insert) {\r\n                if (this._cacheKey !== key) {\r\n                    this._cacheIndex = this._keys.indexOf(this._cacheKey = key);\r\n                }\r\n                if (this._cacheIndex < 0 && insert) {\r\n                    this._cacheIndex = this._keys.length;\r\n                    this._keys.push(key);\r\n                    this._values.push(undefined);\r\n                }\r\n                return this._cacheIndex;\r\n            };\r\n            return Map;\r\n        }());\r\n        function getKey(key, _) {\r\n            return key;\r\n        }\r\n        function getValue(_, value) {\r\n            return value;\r\n        }\r\n        function getEntry(key, value) {\r\n            return [key, value];\r\n        }\r\n    }\r\n    // naive Set shim\r\n    function CreateSetPolyfill() {\r\n        return (function () {\r\n            function Set() {\r\n                this._map = new _Map();\r\n            }\r\n            Object.defineProperty(Set.prototype, \"size\", {\r\n                get: function () { return this._map.size; },\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n            Set.prototype.has = function (value) { return this._map.has(value); };\r\n            Set.prototype.add = function (value) { return this._map.set(value, value), this; };\r\n            Set.prototype.delete = function (value) { return this._map.delete(value); };\r\n            Set.prototype.clear = function () { this._map.clear(); };\r\n            Set.prototype.keys = function () { return this._map.keys(); };\r\n            Set.prototype.values = function () { return this._map.values(); };\r\n            Set.prototype.entries = function () { return this._map.entries(); };\r\n            Set.prototype[\"@@iterator\"] = function () { return this.keys(); };\r\n            Set.prototype[iteratorSymbol] = function () { return this.keys(); };\r\n            return Set;\r\n        }());\r\n    }\r\n    // naive WeakMap shim\r\n    function CreateWeakMapPolyfill() {\r\n        var UUID_SIZE = 16;\r\n        var keys = HashMap.create();\r\n        var rootKey = CreateUniqueKey();\r\n        return (function () {\r\n            function WeakMap() {\r\n                this._key = CreateUniqueKey();\r\n            }\r\n            WeakMap.prototype.has = function (target) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                return table !== undefined ? HashMap.has(table, this._key) : false;\r\n            };\r\n            WeakMap.prototype.get = function (target) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                return table !== undefined ? HashMap.get(table, this._key) : undefined;\r\n            };\r\n            WeakMap.prototype.set = function (target, value) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ true);\r\n                table[this._key] = value;\r\n                return this;\r\n            };\r\n            WeakMap.prototype.delete = function (target) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                return table !== undefined ? delete table[this._key] : false;\r\n            };\r\n            WeakMap.prototype.clear = function () {\r\n                // NOTE: not a real clear, just makes the previous data unreachable\r\n                this._key = CreateUniqueKey();\r\n            };\r\n            return WeakMap;\r\n        }());\r\n        function CreateUniqueKey() {\r\n            var key;\r\n            do\r\n                key = \"@@WeakMap@@\" + CreateUUID();\r\n            while (HashMap.has(keys, key));\r\n            keys[key] = true;\r\n            return key;\r\n        }\r\n        function GetOrCreateWeakMapTable(target, create) {\r\n            if (!hasOwn.call(target, rootKey)) {\r\n                if (!create)\r\n                    return undefined;\r\n                Object.defineProperty(target, rootKey, { value: HashMap.create() });\r\n            }\r\n            return target[rootKey];\r\n        }\r\n        function FillRandomBytes(buffer, size) {\r\n            for (var i = 0; i < size; ++i)\r\n                buffer[i] = Math.random() * 0xff | 0;\r\n            return buffer;\r\n        }\r\n        function GenRandomBytes(size) {\r\n            if (typeof Uint8Array === \"function\") {\r\n                if (typeof crypto !== \"undefined\")\r\n                    return crypto.getRandomValues(new Uint8Array(size));\r\n                if (typeof msCrypto !== \"undefined\")\r\n                    return msCrypto.getRandomValues(new Uint8Array(size));\r\n                return FillRandomBytes(new Uint8Array(size), size);\r\n            }\r\n            return FillRandomBytes(new Array(size), size);\r\n        }\r\n        function CreateUUID() {\r\n            var data = GenRandomBytes(UUID_SIZE);\r\n            // mark as random - RFC 4122  4.4\r\n            data[6] = data[6] & 0x4f | 0x40;\r\n            data[8] = data[8] & 0xbf | 0x80;\r\n            var result = \"\";\r\n            for (var offset = 0; offset < UUID_SIZE; ++offset) {\r\n                var byte = data[offset];\r\n                if (offset === 4 || offset === 6 || offset === 8)\r\n                    result += \"-\";\r\n                if (byte < 16)\r\n                    result += \"0\";\r\n                result += byte.toString(16).toLowerCase();\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.\r\n    function MakeDictionary(obj) {\r\n        obj.__ = undefined;\r\n        delete obj.__;\r\n        return obj;\r\n    }\r\n    // patch global Reflect\r\n    (function (__global) {\r\n        if (typeof __global.Reflect !== \"undefined\") {\r\n            if (__global.Reflect !== Reflect) {\r\n                for (var p in Reflect) {\r\n                    if (hasOwn.call(Reflect, p)) {\r\n                        __global.Reflect[p] = Reflect[p];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            __global.Reflect = Reflect;\r\n        }\r\n    })(typeof global !== \"undefined\" ? global :\r\n        typeof self !== \"undefined\" ? self :\r\n            Function(\"return this;\")());\r\n})(Reflect || (Reflect = {}));\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24), __webpack_require__(16)))\n\n/***/ }),\n\n/***/ \"./node_modules/zone.js/dist/zone.js\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\n(function (global, factory) {\n\t true ? factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(factory());\n}(this, (function () { 'use strict';\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Zone$1 = (function (global) {\n    var performance = global['performance'];\n    function mark(name) {\n        performance && performance['mark'] && performance['mark'](name);\n    }\n    function performanceMeasure(name, label) {\n        performance && performance['measure'] && performance['measure'](name, label);\n    }\n    mark('Zone');\n    if (global['Zone']) {\n        throw new Error('Zone already loaded.');\n    }\n    var Zone = (function () {\n        function Zone(parent, zoneSpec) {\n            this._properties = null;\n            this._parent = parent;\n            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';\n            this._properties = zoneSpec && zoneSpec.properties || {};\n            this._zoneDelegate =\n                new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n        }\n        Zone.assertZonePatched = function () {\n            if (global['Promise'] !== patches['ZoneAwarePromise']) {\n                throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +\n                    'has been overwritten.\\n' +\n                    'Most likely cause is that a Promise polyfill has been loaded ' +\n                    'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +\n                    'If you must load one, do so before loading zone.js.)');\n            }\n        };\n        Object.defineProperty(Zone, \"root\", {\n            get: function () {\n                var zone = Zone.current;\n                while (zone.parent) {\n                    zone = zone.parent;\n                }\n                return zone;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Zone, \"current\", {\n            get: function () {\n                return _currentZoneFrame.zone;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Object.defineProperty(Zone, \"currentTask\", {\n            get: function () {\n                return _currentTask;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Zone.__load_patch = function (name, fn) {\n            if (patches.hasOwnProperty(name)) {\n                throw Error('Already loaded patch: ' + name);\n            }\n            else if (!global['__Zone_disable_' + name]) {\n                var perfName = 'Zone:' + name;\n                mark(perfName);\n                patches[name] = fn(global, Zone, _api);\n                performanceMeasure(perfName, perfName);\n            }\n        };\n        Object.defineProperty(Zone.prototype, \"parent\", {\n            get: function () {\n                return this._parent;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Object.defineProperty(Zone.prototype, \"name\", {\n            get: function () {\n                return this._name;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Zone.prototype.get = function (key) {\n            var zone = this.getZoneWith(key);\n            if (zone)\n                return zone._properties[key];\n        };\n        Zone.prototype.getZoneWith = function (key) {\n            var current = this;\n            while (current) {\n                if (current._properties.hasOwnProperty(key)) {\n                    return current;\n                }\n                current = current._parent;\n            }\n            return null;\n        };\n        Zone.prototype.fork = function (zoneSpec) {\n            if (!zoneSpec)\n                throw new Error('ZoneSpec required!');\n            return this._zoneDelegate.fork(this, zoneSpec);\n        };\n        Zone.prototype.wrap = function (callback, source) {\n            if (typeof callback !== 'function') {\n                throw new Error('Expecting function got: ' + callback);\n            }\n            var _callback = this._zoneDelegate.intercept(this, callback, source);\n            var zone = this;\n            return function () {\n                return zone.runGuarded(_callback, this, arguments, source);\n            };\n        };\n        Zone.prototype.run = function (callback, applyThis, applyArgs, source) {\n            if (applyThis === void 0) { applyThis = undefined; }\n            if (applyArgs === void 0) { applyArgs = null; }\n            if (source === void 0) { source = null; }\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        };\n        Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {\n            if (applyThis === void 0) { applyThis = null; }\n            if (applyArgs === void 0) { applyArgs = null; }\n            if (source === void 0) { source = null; }\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                try {\n                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        };\n        Zone.prototype.runTask = function (task, applyThis, applyArgs) {\n            if (task.zone != this) {\n                throw new Error('A task can only be run in the zone of creation! (Creation: ' +\n                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n            }\n            // https://github.com/angular/zone.js/issues/778, sometimes eventTask\n            // will run in notScheduled(canceled) state, we should not try to\n            // run such kind of task but just return\n            // we have to define an variable here, if not\n            // typescript compiler will complain below\n            var isNotScheduled = task.state === notScheduled;\n            if (isNotScheduled && task.type === eventTask) {\n                return;\n            }\n            var reEntryGuard = task.state != running;\n            reEntryGuard && task._transitionTo(running, scheduled);\n            task.runCount++;\n            var previousTask = _currentTask;\n            _currentTask = task;\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                if (task.type == macroTask && task.data && !task.data.isPeriodic) {\n                    task.cancelFn = null;\n                }\n                try {\n                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                // if the task's state is notScheduled or unknown, then it has already been cancelled\n                // we should not reset the state to scheduled\n                if (task.state !== notScheduled && task.state !== unknown) {\n                    if (task.type == eventTask || (task.data && task.data.isPeriodic)) {\n                        reEntryGuard && task._transitionTo(scheduled, running);\n                    }\n                    else {\n                        task.runCount = 0;\n                        this._updateTaskCount(task, -1);\n                        reEntryGuard &&\n                            task._transitionTo(notScheduled, running, notScheduled);\n                    }\n                }\n                _currentZoneFrame = _currentZoneFrame.parent;\n                _currentTask = previousTask;\n            }\n        };\n        Zone.prototype.scheduleTask = function (task) {\n            if (task.zone && task.zone !== this) {\n                // check if the task was rescheduled, the newZone\n                // should not be the children of the original zone\n                var newZone = this;\n                while (newZone) {\n                    if (newZone === task.zone) {\n                        throw Error(\"can not reschedule task to \" + this\n                            .name + \" which is descendants of the original zone \" + task.zone.name);\n                    }\n                    newZone = newZone.parent;\n                }\n            }\n            task._transitionTo(scheduling, notScheduled);\n            var zoneDelegates = [];\n            task._zoneDelegates = zoneDelegates;\n            task._zone = this;\n            try {\n                task = this._zoneDelegate.scheduleTask(this, task);\n            }\n            catch (err) {\n                // should set task's state to unknown when scheduleTask throw error\n                // because the err may from reschedule, so the fromState maybe notScheduled\n                task._transitionTo(unknown, scheduling, notScheduled);\n                // TODO: @JiaLiPassion, should we check the result from handleError?\n                this._zoneDelegate.handleError(this, err);\n                throw err;\n            }\n            if (task._zoneDelegates === zoneDelegates) {\n                // we have to check because internally the delegate can reschedule the task.\n                this._updateTaskCount(task, 1);\n            }\n            if (task.state == scheduling) {\n                task._transitionTo(scheduled, scheduling);\n            }\n            return task;\n        };\n        Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {\n            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, null));\n        };\n        Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {\n            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\n        };\n        Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {\n            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\n        };\n        Zone.prototype.cancelTask = function (task) {\n            if (task.zone != this)\n                throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' +\n                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n            task._transitionTo(canceling, scheduled, running);\n            try {\n                this._zoneDelegate.cancelTask(this, task);\n            }\n            catch (err) {\n                // if error occurs when cancelTask, transit the state to unknown\n                task._transitionTo(unknown, canceling);\n                this._zoneDelegate.handleError(this, err);\n                throw err;\n            }\n            this._updateTaskCount(task, -1);\n            task._transitionTo(notScheduled, canceling);\n            task.runCount = 0;\n            return task;\n        };\n        Zone.prototype._updateTaskCount = function (task, count) {\n            var zoneDelegates = task._zoneDelegates;\n            if (count == -1) {\n                task._zoneDelegates = null;\n            }\n            for (var i = 0; i < zoneDelegates.length; i++) {\n                zoneDelegates[i]._updateTaskCount(task.type, count);\n            }\n        };\n        return Zone;\n    }());\n    Zone.__symbol__ = __symbol__;\n    var DELEGATE_ZS = {\n        name: '',\n        onHasTask: function (delegate, _, target, hasTaskState) {\n            return delegate.hasTask(target, hasTaskState);\n        },\n        onScheduleTask: function (delegate, _, target, task) {\n            return delegate.scheduleTask(target, task);\n        },\n        onInvokeTask: function (delegate, _, target, task, applyThis, applyArgs) { return delegate.invokeTask(target, task, applyThis, applyArgs); },\n        onCancelTask: function (delegate, _, target, task) {\n            return delegate.cancelTask(target, task);\n        }\n    };\n    var ZoneDelegate = (function () {\n        function ZoneDelegate(zone, parentDelegate, zoneSpec) {\n            this._taskCounts = { 'microTask': 0, 'macroTask': 0, 'eventTask': 0 };\n            this.zone = zone;\n            this._parentDelegate = parentDelegate;\n            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n            this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate.zone);\n            this._interceptZS =\n                zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n            this._interceptDlgt =\n                zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n            this._interceptCurrZone =\n                zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);\n            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n            this._invokeDlgt =\n                zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n            this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);\n            this._handleErrorZS =\n                zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n            this._handleErrorDlgt =\n                zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n            this._handleErrorCurrZone =\n                zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);\n            this._scheduleTaskZS =\n                zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n            this._scheduleTaskDlgt =\n                zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n            this._scheduleTaskCurrZone =\n                zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);\n            this._invokeTaskZS =\n                zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n            this._invokeTaskDlgt =\n                zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n            this._invokeTaskCurrZone =\n                zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);\n            this._cancelTaskZS =\n                zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n            this._cancelTaskDlgt =\n                zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n            this._cancelTaskCurrZone =\n                zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);\n            this._hasTaskZS = null;\n            this._hasTaskDlgt = null;\n            this._hasTaskDlgtOwner = null;\n            this._hasTaskCurrZone = null;\n            var zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\n            var parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\n            if (zoneSpecHasTask || parentHasTask) {\n                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such\n                // a case all task related interceptors must go through this ZD. We can't short circuit it.\n                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\n                this._hasTaskDlgt = parentDelegate;\n                this._hasTaskDlgtOwner = this;\n                this._hasTaskCurrZone = zone;\n                if (!zoneSpec.onScheduleTask) {\n                    this._scheduleTaskZS = DELEGATE_ZS;\n                    this._scheduleTaskDlgt = parentDelegate;\n                    this._scheduleTaskCurrZone = this.zone;\n                }\n                if (!zoneSpec.onInvokeTask) {\n                    this._invokeTaskZS = DELEGATE_ZS;\n                    this._invokeTaskDlgt = parentDelegate;\n                    this._invokeTaskCurrZone = this.zone;\n                }\n                if (!zoneSpec.onCancelTask) {\n                    this._cancelTaskZS = DELEGATE_ZS;\n                    this._cancelTaskDlgt = parentDelegate;\n                    this._cancelTaskCurrZone = this.zone;\n                }\n            }\n        }\n        ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {\n            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :\n                new Zone(targetZone, zoneSpec);\n        };\n        ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {\n            return this._interceptZS ?\n                this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) :\n                callback;\n        };\n        ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {\n            return this._invokeZS ?\n                this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) :\n                callback.apply(applyThis, applyArgs);\n        };\n        ZoneDelegate.prototype.handleError = function (targetZone, error) {\n            return this._handleErrorZS ?\n                this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) :\n                true;\n        };\n        ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {\n            var returnTask = task;\n            if (this._scheduleTaskZS) {\n                if (this._hasTaskZS) {\n                    returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\n                }\n                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);\n                if (!returnTask)\n                    returnTask = task;\n            }\n            else {\n                if (task.scheduleFn) {\n                    task.scheduleFn(task);\n                }\n                else if (task.type == microTask) {\n                    scheduleMicroTask(task);\n                }\n                else {\n                    throw new Error('Task is missing scheduleFn.');\n                }\n            }\n            return returnTask;\n        };\n        ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {\n            return this._invokeTaskZS ?\n                this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) :\n                task.callback.apply(applyThis, applyArgs);\n        };\n        ZoneDelegate.prototype.cancelTask = function (targetZone, task) {\n            var value;\n            if (this._cancelTaskZS) {\n                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\n            }\n            else {\n                if (!task.cancelFn) {\n                    throw Error('Task is not cancelable');\n                }\n                value = task.cancelFn(task);\n            }\n            return value;\n        };\n        ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {\n            // hasTask should not throw error so other ZoneDelegate\n            // can still trigger hasTask callback\n            try {\n                return this._hasTaskZS &&\n                    this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\n            }\n            catch (err) {\n                this.handleError(targetZone, err);\n            }\n        };\n        ZoneDelegate.prototype._updateTaskCount = function (type, count) {\n            var counts = this._taskCounts;\n            var prev = counts[type];\n            var next = counts[type] = prev + count;\n            if (next < 0) {\n                throw new Error('More tasks executed then were scheduled.');\n            }\n            if (prev == 0 || next == 0) {\n                var isEmpty = {\n                    microTask: counts.microTask > 0,\n                    macroTask: counts.macroTask > 0,\n                    eventTask: counts.eventTask > 0,\n                    change: type\n                };\n                this.hasTask(this.zone, isEmpty);\n            }\n        };\n        return ZoneDelegate;\n    }());\n    var ZoneTask = (function () {\n        function ZoneTask(type, source, callback, options, scheduleFn, cancelFn) {\n            this._zone = null;\n            this.runCount = 0;\n            this._zoneDelegates = null;\n            this._state = 'notScheduled';\n            this.type = type;\n            this.source = source;\n            this.data = options;\n            this.scheduleFn = scheduleFn;\n            this.cancelFn = cancelFn;\n            this.callback = callback;\n            var self = this;\n            this.invoke = function () {\n                _numberOfNestedTaskFrames++;\n                try {\n                    self.runCount++;\n                    return self.zone.runTask(self, this, arguments);\n                }\n                finally {\n                    if (_numberOfNestedTaskFrames == 1) {\n                        drainMicroTaskQueue();\n                    }\n                    _numberOfNestedTaskFrames--;\n                }\n            };\n        }\n        Object.defineProperty(ZoneTask.prototype, \"zone\", {\n            get: function () {\n                return this._zone;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ZoneTask.prototype, \"state\", {\n            get: function () {\n                return this._state;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ZoneTask.prototype.cancelScheduleRequest = function () {\n            this._transitionTo(notScheduled, scheduling);\n        };\n        ZoneTask.prototype._transitionTo = function (toState, fromState1, fromState2) {\n            if (this._state === fromState1 || this._state === fromState2) {\n                this._state = toState;\n                if (toState == notScheduled) {\n                    this._zoneDelegates = null;\n                }\n            }\n            else {\n                throw new Error(this.type + \" '\" + this.source + \"': can not transition to '\" + toState + \"', expecting state '\" + fromState1 + \"'\" + (fromState2 ?\n                    ' or \\'' + fromState2 + '\\'' :\n                    '') + \", was '\" + this._state + \"'.\");\n            }\n        };\n        ZoneTask.prototype.toString = function () {\n            if (this.data && typeof this.data.handleId !== 'undefined') {\n                return this.data.handleId;\n            }\n            else {\n                return Object.prototype.toString.call(this);\n            }\n        };\n        // add toJSON method to prevent cyclic error when\n        // call JSON.stringify(zoneTask)\n        ZoneTask.prototype.toJSON = function () {\n            return {\n                type: this.type,\n                state: this.state,\n                source: this.source,\n                zone: this.zone.name,\n                invoke: this.invoke,\n                scheduleFn: this.scheduleFn,\n                cancelFn: this.cancelFn,\n                runCount: this.runCount,\n                callback: this.callback\n            };\n        };\n        return ZoneTask;\n    }());\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    ///  MICROTASK QUEUE\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    var symbolSetTimeout = __symbol__('setTimeout');\n    var symbolPromise = __symbol__('Promise');\n    var symbolThen = __symbol__('then');\n    var _microTaskQueue = [];\n    var _isDrainingMicrotaskQueue = false;\n    function scheduleMicroTask(task) {\n        // if we are not running in any task, and there has not been anything scheduled\n        // we must bootstrap the initial task creation by manually scheduling the drain\n        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\n            // We are not running in Task, so we need to kickstart the microtask queue.\n            if (global[symbolPromise]) {\n                global[symbolPromise].resolve(0)[symbolThen](drainMicroTaskQueue);\n            }\n            else {\n                global[symbolSetTimeout](drainMicroTaskQueue, 0);\n            }\n        }\n        task && _microTaskQueue.push(task);\n    }\n    function drainMicroTaskQueue() {\n        if (!_isDrainingMicrotaskQueue) {\n            _isDrainingMicrotaskQueue = true;\n            while (_microTaskQueue.length) {\n                var queue = _microTaskQueue;\n                _microTaskQueue = [];\n                for (var i = 0; i < queue.length; i++) {\n                    var task = queue[i];\n                    try {\n                        task.zone.runTask(task, null, null);\n                    }\n                    catch (error) {\n                        _api.onUnhandledError(error);\n                    }\n                }\n            }\n            var showError = !Zone[__symbol__('ignoreConsoleErrorUncaughtError')];\n            _api.microtaskDrainDone();\n            _isDrainingMicrotaskQueue = false;\n        }\n    }\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    ///  BOOTSTRAP\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    var NO_ZONE = { name: 'NO ZONE' };\n    var notScheduled = 'notScheduled', scheduling = 'scheduling', scheduled = 'scheduled', running = 'running', canceling = 'canceling', unknown = 'unknown';\n    var microTask = 'microTask', macroTask = 'macroTask', eventTask = 'eventTask';\n    var patches = {};\n    var _api = {\n        symbol: __symbol__,\n        currentZoneFrame: function () { return _currentZoneFrame; },\n        onUnhandledError: noop,\n        microtaskDrainDone: noop,\n        scheduleMicroTask: scheduleMicroTask,\n        showUncaughtError: function () { return !Zone[__symbol__('ignoreConsoleErrorUncaughtError')]; },\n        patchEventTargetMethods: function () { return false; },\n        patchOnProperties: noop\n    };\n    var _currentZoneFrame = { parent: null, zone: new Zone(null, null) };\n    var _currentTask = null;\n    var _numberOfNestedTaskFrames = 0;\n    function noop() { }\n    function __symbol__(name) {\n        return '__zone_symbol__' + name;\n    }\n    performanceMeasure('Zone', 'Zone');\n    return global['Zone'] = Zone;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('ZoneAwarePromise', function (global, Zone, api) {\n    var __symbol__ = api.symbol;\n    var _uncaughtPromiseErrors = [];\n    var symbolPromise = __symbol__('Promise');\n    var symbolThen = __symbol__('then');\n    api.onUnhandledError = function (e) {\n        if (api.showUncaughtError()) {\n            var rejection = e && e.rejection;\n            if (rejection) {\n                console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);\n            }\n            console.error(e);\n        }\n    };\n    api.microtaskDrainDone = function () {\n        while (_uncaughtPromiseErrors.length) {\n            var _loop_1 = function () {\n                var uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n                try {\n                    uncaughtPromiseError.zone.runGuarded(function () {\n                        throw uncaughtPromiseError;\n                    });\n                }\n                catch (error) {\n                    handleUnhandledRejection(error);\n                }\n            };\n            while (_uncaughtPromiseErrors.length) {\n                _loop_1();\n            }\n        }\n    };\n    function handleUnhandledRejection(e) {\n        api.onUnhandledError(e);\n        try {\n            var handler = Zone[__symbol__('unhandledPromiseRejectionHandler')];\n            if (handler && typeof handler === 'function') {\n                handler.apply(this, [e]);\n            }\n        }\n        catch (err) {\n        }\n    }\n    function isThenable(value) {\n        return value && value.then;\n    }\n    function forwardResolution(value) {\n        return value;\n    }\n    function forwardRejection(rejection) {\n        return ZoneAwarePromise.reject(rejection);\n    }\n    var symbolState = __symbol__('state');\n    var symbolValue = __symbol__('value');\n    var source = 'Promise.then';\n    var UNRESOLVED = null;\n    var RESOLVED = true;\n    var REJECTED = false;\n    var REJECTED_NO_CATCH = 0;\n    function makeResolver(promise, state) {\n        return function (v) {\n            try {\n                resolvePromise(promise, state, v);\n            }\n            catch (err) {\n                resolvePromise(promise, false, err);\n            }\n            // Do not return value or you will break the Promise spec.\n        };\n    }\n    var once = function () {\n        var wasCalled = false;\n        return function wrapper(wrappedFunction) {\n            return function () {\n                if (wasCalled) {\n                    return;\n                }\n                wasCalled = true;\n                wrappedFunction.apply(null, arguments);\n            };\n        };\n    };\n    // Promise Resolution\n    function resolvePromise(promise, state, value) {\n        var onceWrapper = once();\n        if (promise === value) {\n            throw new TypeError('Promise resolved with itself');\n        }\n        if (promise[symbolState] === UNRESOLVED) {\n            // should only get value.then once based on promise spec.\n            var then = null;\n            try {\n                if (typeof value === 'object' || typeof value === 'function') {\n                    then = value && value.then;\n                }\n            }\n            catch (err) {\n                onceWrapper(function () {\n                    resolvePromise(promise, false, err);\n                })();\n                return promise;\n            }\n            // if (value instanceof ZoneAwarePromise) {\n            if (state !== REJECTED && value instanceof ZoneAwarePromise &&\n                value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) &&\n                value[symbolState] !== UNRESOLVED) {\n                clearRejectedNoCatch(value);\n                resolvePromise(promise, value[symbolState], value[symbolValue]);\n            }\n            else if (state !== REJECTED && typeof then === 'function') {\n                try {\n                    then.apply(value, [\n                        onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false))\n                    ]);\n                }\n                catch (err) {\n                    onceWrapper(function () {\n                        resolvePromise(promise, false, err);\n                    })();\n                }\n            }\n            else {\n                promise[symbolState] = state;\n                var queue = promise[symbolValue];\n                promise[symbolValue] = value;\n                // record task information in value when error occurs, so we can\n                // do some additional work such as render longStackTrace\n                if (state === REJECTED && value instanceof Error) {\n                    value[__symbol__('currentTask')] = Zone.currentTask;\n                }\n                for (var i = 0; i < queue.length;) {\n                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n                }\n                if (queue.length == 0 && state == REJECTED) {\n                    promise[symbolState] = REJECTED_NO_CATCH;\n                    try {\n                        throw new Error('Uncaught (in promise): ' + value +\n                            (value && value.stack ? '\\n' + value.stack : ''));\n                    }\n                    catch (err) {\n                        var error_1 = err;\n                        error_1.rejection = value;\n                        error_1.promise = promise;\n                        error_1.zone = Zone.current;\n                        error_1.task = Zone.currentTask;\n                        _uncaughtPromiseErrors.push(error_1);\n                        api.scheduleMicroTask(); // to make sure that it is running\n                    }\n                }\n            }\n        }\n        // Resolving an already resolved promise is a noop.\n        return promise;\n    }\n    function clearRejectedNoCatch(promise) {\n        if (promise[symbolState] === REJECTED_NO_CATCH) {\n            // if the promise is rejected no catch status\n            // and queue.length > 0, means there is a error handler\n            // here to handle the rejected promise, we should trigger\n            // windows.rejectionhandled eventHandler or nodejs rejectionHandled\n            // eventHandler\n            try {\n                var handler = Zone[__symbol__('rejectionHandledHandler')];\n                if (handler && typeof handler === 'function') {\n                    handler.apply(this, [{ rejection: promise[symbolValue], promise: promise }]);\n                }\n            }\n            catch (err) {\n            }\n            promise[symbolState] = REJECTED;\n            for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {\n                if (promise === _uncaughtPromiseErrors[i].promise) {\n                    _uncaughtPromiseErrors.splice(i, 1);\n                }\n            }\n        }\n    }\n    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n        clearRejectedNoCatch(promise);\n        var delegate = promise[symbolState] ?\n            (typeof onFulfilled === 'function') ? onFulfilled : forwardResolution :\n            (typeof onRejected === 'function') ? onRejected : forwardRejection;\n        zone.scheduleMicroTask(source, function () {\n            try {\n                resolvePromise(chainPromise, true, zone.run(delegate, undefined, [promise[symbolValue]]));\n            }\n            catch (error) {\n                resolvePromise(chainPromise, false, error);\n            }\n        });\n    }\n    var ZoneAwarePromise = (function () {\n        function ZoneAwarePromise(executor) {\n            var promise = this;\n            if (!(promise instanceof ZoneAwarePromise)) {\n                throw new Error('Must be an instanceof Promise.');\n            }\n            promise[symbolState] = UNRESOLVED;\n            promise[symbolValue] = []; // queue;\n            try {\n                executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));\n            }\n            catch (error) {\n                resolvePromise(promise, false, error);\n            }\n        }\n        ZoneAwarePromise.toString = function () {\n            return 'function ZoneAwarePromise() { [native code] }';\n        };\n        ZoneAwarePromise.resolve = function (value) {\n            return resolvePromise(new this(null), RESOLVED, value);\n        };\n        ZoneAwarePromise.reject = function (error) {\n            return resolvePromise(new this(null), REJECTED, error);\n        };\n        ZoneAwarePromise.race = function (values) {\n            var resolve;\n            var reject;\n            var promise = new this(function (res, rej) {\n                _a = [res, rej], resolve = _a[0], reject = _a[1];\n                var _a;\n            });\n            function onResolve(value) {\n                promise && (promise = null || resolve(value));\n            }\n            function onReject(error) {\n                promise && (promise = null || reject(error));\n            }\n            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n                var value = values_1[_i];\n                if (!isThenable(value)) {\n                    value = this.resolve(value);\n                }\n                value.then(onResolve, onReject);\n            }\n            return promise;\n        };\n        ZoneAwarePromise.all = function (values) {\n            var resolve;\n            var reject;\n            var promise = new this(function (res, rej) {\n                resolve = res;\n                reject = rej;\n            });\n            var count = 0;\n            var resolvedValues = [];\n            for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {\n                var value = values_2[_i];\n                if (!isThenable(value)) {\n                    value = this.resolve(value);\n                }\n                value.then((function (index) { return function (value) {\n                    resolvedValues[index] = value;\n                    count--;\n                    if (!count) {\n                        resolve(resolvedValues);\n                    }\n                }; })(count), reject);\n                count++;\n            }\n            if (!count)\n                resolve(resolvedValues);\n            return promise;\n        };\n        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {\n            var chainPromise = new this.constructor(null);\n            var zone = Zone.current;\n            if (this[symbolState] == UNRESOLVED) {\n                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n            }\n            else {\n                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n            }\n            return chainPromise;\n        };\n        ZoneAwarePromise.prototype.catch = function (onRejected) {\n            return this.then(null, onRejected);\n        };\n        return ZoneAwarePromise;\n    }());\n    // Protect against aggressive optimizers dropping seemingly unused properties.\n    // E.g. Closure Compiler in advanced mode.\n    ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;\n    ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;\n    ZoneAwarePromise['race'] = ZoneAwarePromise.race;\n    ZoneAwarePromise['all'] = ZoneAwarePromise.all;\n    var NativePromise = global[symbolPromise] = global['Promise'];\n    global['Promise'] = ZoneAwarePromise;\n    var symbolThenPatched = __symbol__('thenPatched');\n    function patchThen(Ctor) {\n        var proto = Ctor.prototype;\n        var originalThen = proto.then;\n        // Keep a reference to the original method.\n        proto[symbolThen] = originalThen;\n        Ctor.prototype.then = function (onResolve, onReject) {\n            var _this = this;\n            var wrapped = new ZoneAwarePromise(function (resolve, reject) {\n                originalThen.call(_this, resolve, reject);\n            });\n            return wrapped.then(onResolve, onReject);\n        };\n        Ctor[symbolThenPatched] = true;\n    }\n    function zoneify(fn) {\n        return function () {\n            var resultPromise = fn.apply(this, arguments);\n            if (resultPromise instanceof ZoneAwarePromise) {\n                return resultPromise;\n            }\n            var ctor = resultPromise.constructor;\n            if (!ctor[symbolThenPatched]) {\n                patchThen(ctor);\n            }\n            return resultPromise;\n        };\n    }\n    if (NativePromise) {\n        patchThen(NativePromise);\n        var fetch_1 = global['fetch'];\n        if (typeof fetch_1 == 'function') {\n            global['fetch'] = zoneify(fetch_1);\n        }\n    }\n    // This is not part of public API, but it is useful for tests, so we expose it.\n    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;\n    return ZoneAwarePromise;\n});\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Suppress closure compiler errors about unknown 'Zone' variable\n * @fileoverview\n * @suppress {undefinedVars,globalThis}\n */\nvar zoneSymbol = function (n) { return \"__zone_symbol__\" + n; };\nvar _global = typeof window === 'object' && window || typeof self === 'object' && self || global;\nfunction bindArguments(args, source) {\n    for (var i = args.length - 1; i >= 0; i--) {\n        if (typeof args[i] === 'function') {\n            args[i] = Zone.current.wrap(args[i], source + '_' + i);\n        }\n    }\n    return args;\n}\nfunction patchPrototype(prototype, fnNames) {\n    var source = prototype.constructor['name'];\n    var _loop_1 = function (i) {\n        var name_1 = fnNames[i];\n        var delegate = prototype[name_1];\n        if (delegate) {\n            prototype[name_1] = (function (delegate) {\n                var patched = function () {\n                    return delegate.apply(this, bindArguments(arguments, source + '.' + name_1));\n                };\n                attachOriginToPatched(patched, delegate);\n                return patched;\n            })(delegate);\n        }\n    };\n    for (var i = 0; i < fnNames.length; i++) {\n        _loop_1(i);\n    }\n}\nvar isWebWorker = (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope);\n// Make sure to access `process` through `_global` so that WebPack does not accidently browserify\n// this code.\nvar isNode = (!('nw' in _global) && typeof _global.process !== 'undefined' &&\n    {}.toString.call(_global.process) === '[object process]');\nvar isBrowser = !isNode && !isWebWorker && !!(typeof window !== 'undefined' && window['HTMLElement']);\n// we are in electron of nw, so we are both browser and nodejs\n// Make sure to access `process` through `_global` so that WebPack does not accidently browserify\n// this code.\nvar isMix = typeof _global.process !== 'undefined' &&\n    {}.toString.call(_global.process) === '[object process]' && !isWebWorker &&\n    !!(typeof window !== 'undefined' && window['HTMLElement']);\nfunction patchProperty(obj, prop, prototype) {\n    var desc = Object.getOwnPropertyDescriptor(obj, prop);\n    if (!desc && prototype) {\n        // when patch window object, use prototype to check prop exist or not\n        var prototypeDesc = Object.getOwnPropertyDescriptor(prototype, prop);\n        if (prototypeDesc) {\n            desc = { enumerable: true, configurable: true };\n        }\n    }\n    // if the descriptor not exists or is not configurable\n    // just return\n    if (!desc || !desc.configurable) {\n        return;\n    }\n    // A property descriptor cannot have getter/setter and be writable\n    // deleting the writable and value properties avoids this error:\n    //\n    // TypeError: property descriptors must not specify a value or be writable when a\n    // getter or setter has been specified\n    delete desc.writable;\n    delete desc.value;\n    var originalDescGet = desc.get;\n    // substr(2) cuz 'onclick' -> 'click', etc\n    var eventName = prop.substr(2);\n    var _prop = zoneSymbol('_' + prop);\n    desc.set = function (newValue) {\n        // in some of windows's onproperty callback, this is undefined\n        // so we need to check it\n        var target = this;\n        if (!target && obj === _global) {\n            target = _global;\n        }\n        if (!target) {\n            return;\n        }\n        var previousValue = target[_prop];\n        if (previousValue) {\n            target.removeEventListener(eventName, previousValue);\n        }\n        if (typeof newValue === 'function') {\n            var wrapFn = function (event) {\n                var result = newValue.apply(this, arguments);\n                if (result != undefined && !result) {\n                    event.preventDefault();\n                }\n                return result;\n            };\n            target[_prop] = wrapFn;\n            target.addEventListener(eventName, wrapFn, false);\n        }\n        else {\n            target[_prop] = null;\n        }\n    };\n    // The getter would return undefined for unassigned properties but the default value of an\n    // unassigned property is null\n    desc.get = function () {\n        // in some of windows's onproperty callback, this is undefined\n        // so we need to check it\n        var target = this;\n        if (!target && obj === _global) {\n            target = _global;\n        }\n        if (!target) {\n            return null;\n        }\n        if (target.hasOwnProperty(_prop)) {\n            return target[_prop];\n        }\n        else if (originalDescGet) {\n            // result will be null when use inline event attribute,\n            // such as <button onclick=\"func();\">OK</button>\n            // because the onclick function is internal raw uncompiled handler\n            // the onclick will be evaluated when first time event was triggered or\n            // the property is accessed, https://github.com/angular/zone.js/issues/525\n            // so we should use original native get to retrieve the handler\n            var value = originalDescGet && originalDescGet.apply(this);\n            if (value) {\n                desc.set.apply(this, [value]);\n                if (typeof target['removeAttribute'] === 'function') {\n                    target.removeAttribute(prop);\n                }\n                return value;\n            }\n        }\n        return null;\n    };\n    Object.defineProperty(obj, prop, desc);\n}\nfunction patchOnProperties(obj, properties, prototype) {\n    if (properties) {\n        for (var i = 0; i < properties.length; i++) {\n            patchProperty(obj, 'on' + properties[i], prototype);\n        }\n    }\n    else {\n        var onProperties = [];\n        for (var prop in obj) {\n            if (prop.substr(0, 2) == 'on') {\n                onProperties.push(prop);\n            }\n        }\n        for (var j = 0; j < onProperties.length; j++) {\n            patchProperty(obj, onProperties[j], prototype);\n        }\n    }\n}\nvar EVENT_TASKS = zoneSymbol('eventTasks');\n// For EventTarget\nvar ADD_EVENT_LISTENER = 'addEventListener';\nvar REMOVE_EVENT_LISTENER = 'removeEventListener';\n// compare the EventListenerOptionsOrCapture\n// 1. if the options is usCapture: boolean, compare the useCpature values directly\n// 2. if the options is EventListerOptions, only compare the capture\nfunction compareEventListenerOptions(left, right) {\n    var leftCapture = (typeof left === 'boolean') ?\n        left :\n        ((typeof left === 'object') ? (left && left.capture) : false);\n    var rightCapture = (typeof right === 'boolean') ?\n        right :\n        ((typeof right === 'object') ? (right && right.capture) : false);\n    return !!leftCapture === !!rightCapture;\n}\nfunction findExistingRegisteredTask(target, handler, name, options, remove) {\n    var eventTasks = target[EVENT_TASKS];\n    if (eventTasks) {\n        for (var i = 0; i < eventTasks.length; i++) {\n            var eventTask = eventTasks[i];\n            var data = eventTask.data;\n            var listener = data.handler;\n            if ((data.handler === handler || listener.listener === handler) &&\n                compareEventListenerOptions(data.options, options) && data.eventName === name) {\n                if (remove) {\n                    eventTasks.splice(i, 1);\n                }\n                return eventTask;\n            }\n        }\n    }\n    return null;\n}\nfunction attachRegisteredEvent(target, eventTask, isPrepend) {\n    var eventTasks = target[EVENT_TASKS];\n    if (!eventTasks) {\n        eventTasks = target[EVENT_TASKS] = [];\n    }\n    if (isPrepend) {\n        eventTasks.unshift(eventTask);\n    }\n    else {\n        eventTasks.push(eventTask);\n    }\n}\nvar defaultListenerMetaCreator = function (self, args) {\n    return {\n        options: args[2],\n        eventName: args[0],\n        handler: args[1],\n        target: self || _global,\n        name: args[0],\n        crossContext: false,\n        invokeAddFunc: function (addFnSymbol, delegate) {\n            // check if the data is cross site context, if it is, fallback to\n            // remove the delegate directly and try catch error\n            if (!this.crossContext) {\n                if (delegate && delegate.invoke) {\n                    return this.target[addFnSymbol](this.eventName, delegate.invoke, this.options);\n                }\n                else {\n                    return this.target[addFnSymbol](this.eventName, delegate, this.options);\n                }\n            }\n            else {\n                // add a if/else branch here for performance concern, for most times\n                // cross site context is false, so we don't need to try/catch\n                try {\n                    return this.target[addFnSymbol](this.eventName, delegate, this.options);\n                }\n                catch (err) {\n                    // do nothing here is fine, because objects in a cross-site context are unusable\n                }\n            }\n        },\n        invokeRemoveFunc: function (removeFnSymbol, delegate) {\n            // check if the data is cross site context, if it is, fallback to\n            // remove the delegate directly and try catch error\n            if (!this.crossContext) {\n                if (delegate && delegate.invoke) {\n                    return this.target[removeFnSymbol](this.eventName, delegate.invoke, this.options);\n                }\n                else {\n                    return this.target[removeFnSymbol](this.eventName, delegate, this.options);\n                }\n            }\n            else {\n                // add a if/else branch here for performance concern, for most times\n                // cross site context is false, so we don't need to try/catch\n                try {\n                    return this.target[removeFnSymbol](this.eventName, delegate, this.options);\n                }\n                catch (err) {\n                    // do nothing here is fine, because objects in a cross-site context are unusable\n                }\n            }\n        }\n    };\n};\nfunction makeZoneAwareAddListener(addFnName, removeFnName, useCapturingParam, allowDuplicates, isPrepend, metaCreator) {\n    if (useCapturingParam === void 0) { useCapturingParam = true; }\n    if (allowDuplicates === void 0) { allowDuplicates = false; }\n    if (isPrepend === void 0) { isPrepend = false; }\n    if (metaCreator === void 0) { metaCreator = defaultListenerMetaCreator; }\n    var addFnSymbol = zoneSymbol(addFnName);\n    var removeFnSymbol = zoneSymbol(removeFnName);\n    var defaultUseCapturing = useCapturingParam ? false : undefined;\n    function scheduleEventListener(eventTask) {\n        var meta = eventTask.data;\n        attachRegisteredEvent(meta.target, eventTask, isPrepend);\n        return meta.invokeAddFunc(addFnSymbol, eventTask);\n    }\n    function cancelEventListener(eventTask) {\n        var meta = eventTask.data;\n        findExistingRegisteredTask(meta.target, eventTask.invoke, meta.eventName, meta.options, true);\n        return meta.invokeRemoveFunc(removeFnSymbol, eventTask);\n    }\n    return function zoneAwareAddListener(self, args) {\n        var data = metaCreator(self, args);\n        data.options = data.options || defaultUseCapturing;\n        // - Inside a Web Worker, `this` is undefined, the context is `global`\n        // - When `addEventListener` is called on the global context in strict mode, `this` is undefined\n        // see https://github.com/angular/zone.js/issues/190\n        var delegate = null;\n        if (typeof data.handler == 'function') {\n            delegate = data.handler;\n        }\n        else if (data.handler && data.handler.handleEvent) {\n            delegate = function (event) { return data.handler.handleEvent(event); };\n        }\n        var validZoneHandler = false;\n        try {\n            // In cross site contexts (such as WebDriver frameworks like Selenium),\n            // accessing the handler object here will cause an exception to be thrown which\n            // will fail tests prematurely.\n            validZoneHandler = data.handler && data.handler.toString() === '[object FunctionWrapper]';\n        }\n        catch (error) {\n            // we can still try to add the data.handler even we are in cross site context\n            data.crossContext = true;\n            return data.invokeAddFunc(addFnSymbol, data.handler);\n        }\n        // Ignore special listeners of IE11 & Edge dev tools, see\n        // https://github.com/angular/zone.js/issues/150\n        if (!delegate || validZoneHandler) {\n            return data.invokeAddFunc(addFnSymbol, data.handler);\n        }\n        if (!allowDuplicates) {\n            var eventTask = findExistingRegisteredTask(data.target, data.handler, data.eventName, data.options, false);\n            if (eventTask) {\n                // we already registered, so this will have noop.\n                return data.invokeAddFunc(addFnSymbol, eventTask);\n            }\n        }\n        var zone = Zone.current;\n        var source = data.target.constructor['name'] + '.' + addFnName + ':' + data.eventName;\n        zone.scheduleEventTask(source, delegate, data, scheduleEventListener, cancelEventListener);\n    };\n}\nfunction makeZoneAwareRemoveListener(fnName, useCapturingParam, metaCreator) {\n    if (useCapturingParam === void 0) { useCapturingParam = true; }\n    if (metaCreator === void 0) { metaCreator = defaultListenerMetaCreator; }\n    var symbol = zoneSymbol(fnName);\n    var defaultUseCapturing = useCapturingParam ? false : undefined;\n    return function zoneAwareRemoveListener(self, args) {\n        var data = metaCreator(self, args);\n        data.options = data.options || defaultUseCapturing;\n        // - Inside a Web Worker, `this` is undefined, the context is `global`\n        // - When `addEventListener` is called on the global context in strict mode, `this` is undefined\n        // see https://github.com/angular/zone.js/issues/190\n        var delegate = null;\n        if (typeof data.handler == 'function') {\n            delegate = data.handler;\n        }\n        else if (data.handler && data.handler.handleEvent) {\n            delegate = function (event) { return data.handler.handleEvent(event); };\n        }\n        var validZoneHandler = false;\n        try {\n            // In cross site contexts (such as WebDriver frameworks like Selenium),\n            // accessing the handler object here will cause an exception to be thrown which\n            // will fail tests prematurely.\n            validZoneHandler = data.handler && data.handler.toString() === '[object FunctionWrapper]';\n        }\n        catch (error) {\n            data.crossContext = true;\n            return data.invokeRemoveFunc(symbol, data.handler);\n        }\n        // Ignore special listeners of IE11 & Edge dev tools, see\n        // https://github.com/angular/zone.js/issues/150\n        if (!delegate || validZoneHandler) {\n            return data.invokeRemoveFunc(symbol, data.handler);\n        }\n        var eventTask = findExistingRegisteredTask(data.target, data.handler, data.eventName, data.options, true);\n        if (eventTask) {\n            eventTask.zone.cancelTask(eventTask);\n        }\n        else {\n            data.invokeRemoveFunc(symbol, data.handler);\n        }\n    };\n}\n\n\nfunction patchEventTargetMethods(obj, addFnName, removeFnName, metaCreator) {\n    if (addFnName === void 0) { addFnName = ADD_EVENT_LISTENER; }\n    if (removeFnName === void 0) { removeFnName = REMOVE_EVENT_LISTENER; }\n    if (metaCreator === void 0) { metaCreator = defaultListenerMetaCreator; }\n    if (obj && obj[addFnName]) {\n        patchMethod(obj, addFnName, function () { return makeZoneAwareAddListener(addFnName, removeFnName, true, false, false, metaCreator); });\n        patchMethod(obj, removeFnName, function () { return makeZoneAwareRemoveListener(removeFnName, true, metaCreator); });\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nvar originalInstanceKey = zoneSymbol('originalInstance');\n// wrap some native API on `window`\nfunction patchClass(className) {\n    var OriginalClass = _global[className];\n    if (!OriginalClass)\n        return;\n    // keep original class in global\n    _global[zoneSymbol(className)] = OriginalClass;\n    _global[className] = function () {\n        var a = bindArguments(arguments, className);\n        switch (a.length) {\n            case 0:\n                this[originalInstanceKey] = new OriginalClass();\n                break;\n            case 1:\n                this[originalInstanceKey] = new OriginalClass(a[0]);\n                break;\n            case 2:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\n                break;\n            case 3:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\n                break;\n            case 4:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\n                break;\n            default:\n                throw new Error('Arg list too long.');\n        }\n    };\n    // attach original delegate to patched function\n    attachOriginToPatched(_global[className], OriginalClass);\n    var instance = new OriginalClass(function () { });\n    var prop;\n    for (prop in instance) {\n        // https://bugs.webkit.org/show_bug.cgi?id=44721\n        if (className === 'XMLHttpRequest' && prop === 'responseBlob')\n            continue;\n        (function (prop) {\n            if (typeof instance[prop] === 'function') {\n                _global[className].prototype[prop] = function () {\n                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\n                };\n            }\n            else {\n                Object.defineProperty(_global[className].prototype, prop, {\n                    set: function (fn) {\n                        if (typeof fn === 'function') {\n                            this[originalInstanceKey][prop] = Zone.current.wrap(fn, className + '.' + prop);\n                            // keep callback in wrapped function so we can\n                            // use it in Function.prototype.toString to return\n                            // the native one.\n                            attachOriginToPatched(this[originalInstanceKey][prop], fn);\n                        }\n                        else {\n                            this[originalInstanceKey][prop] = fn;\n                        }\n                    },\n                    get: function () {\n                        return this[originalInstanceKey][prop];\n                    }\n                });\n            }\n        }(prop));\n    }\n    for (prop in OriginalClass) {\n        if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {\n            _global[className][prop] = OriginalClass[prop];\n        }\n    }\n}\nfunction patchMethod(target, name, patchFn) {\n    var proto = target;\n    while (proto && !proto.hasOwnProperty(name)) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    if (!proto && target[name]) {\n        // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n        proto = target;\n    }\n    var delegateName = zoneSymbol(name);\n    var delegate;\n    if (proto && !(delegate = proto[delegateName])) {\n        delegate = proto[delegateName] = proto[name];\n        var patchDelegate_1 = patchFn(delegate, delegateName, name);\n        proto[name] = function () {\n            return patchDelegate_1(this, arguments);\n        };\n        attachOriginToPatched(proto[name], delegate);\n    }\n    return delegate;\n}\n// TODO: @JiaLiPassion, support cancel task later if necessary\n\n\nfunction findEventTask(target, evtName) {\n    var eventTasks = target[zoneSymbol('eventTasks')];\n    var result = [];\n    if (eventTasks) {\n        for (var i = 0; i < eventTasks.length; i++) {\n            var eventTask = eventTasks[i];\n            var data = eventTask.data;\n            var eventName = data && data.eventName;\n            if (eventName === evtName) {\n                result.push(eventTask);\n            }\n        }\n    }\n    return result;\n}\nfunction attachOriginToPatched(patched, original) {\n    patched[zoneSymbol('OriginalDelegate')] = original;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// override Function.prototype.toString to make zone.js patched function\n// look like native function\nZone.__load_patch('toString', function (global, Zone, api) {\n    // patch Func.prototype.toString to let them look like native\n    var originalFunctionToString = Function.prototype.toString;\n    Function.prototype.toString = function () {\n        if (typeof this === 'function') {\n            if (this[zoneSymbol('OriginalDelegate')]) {\n                return originalFunctionToString.apply(this[zoneSymbol('OriginalDelegate')], arguments);\n            }\n            if (this === Promise) {\n                var nativePromise = global[zoneSymbol('Promise')];\n                if (nativePromise) {\n                    return originalFunctionToString.apply(nativePromise, arguments);\n                }\n            }\n            if (this === Error) {\n                var nativeError = global[zoneSymbol('Error')];\n                if (nativeError) {\n                    return originalFunctionToString.apply(nativeError, arguments);\n                }\n            }\n        }\n        return originalFunctionToString.apply(this, arguments);\n    };\n    // patch Object.prototype.toString to let them look like native\n    var originalObjectToString = Object.prototype.toString;\n    Object.prototype.toString = function () {\n        if (this instanceof Promise) {\n            return '[object Promise]';\n        }\n        return originalObjectToString.apply(this, arguments);\n    };\n});\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction patchTimer(window, setName, cancelName, nameSuffix) {\n    var setNative = null;\n    var clearNative = null;\n    setName += nameSuffix;\n    cancelName += nameSuffix;\n    var tasksByHandleId = {};\n    function scheduleTask(task) {\n        var data = task.data;\n        function timer() {\n            try {\n                task.invoke.apply(this, arguments);\n            }\n            finally {\n                if (typeof data.handleId === 'number') {\n                    // Node returns complex objects as handleIds\n                    delete tasksByHandleId[data.handleId];\n                }\n            }\n        }\n        data.args[0] = timer;\n        data.handleId = setNative.apply(window, data.args);\n        if (typeof data.handleId === 'number') {\n            // Node returns complex objects as handleIds -> no need to keep them around. Additionally,\n            // this throws an\n            // exception in older node versions and has no effect there, because of the stringified key.\n            tasksByHandleId[data.handleId] = task;\n        }\n        return task;\n    }\n    function clearTask(task) {\n        if (typeof task.data.handleId === 'number') {\n            // Node returns complex objects as handleIds\n            delete tasksByHandleId[task.data.handleId];\n        }\n        return clearNative(task.data.handleId);\n    }\n    setNative =\n        patchMethod(window, setName, function (delegate) { return function (self, args) {\n            if (typeof args[0] === 'function') {\n                var zone = Zone.current;\n                var options = {\n                    handleId: null,\n                    isPeriodic: nameSuffix === 'Interval',\n                    delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 : null,\n                    args: args\n                };\n                var task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);\n                if (!task) {\n                    return task;\n                }\n                // Node.js must additionally support the ref and unref functions.\n                var handle = task.data.handleId;\n                // check whether handle is null, because some polyfill or browser\n                // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame\n                if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' &&\n                    typeof handle.unref === 'function') {\n                    task.ref = handle.ref.bind(handle);\n                    task.unref = handle.unref.bind(handle);\n                }\n                return task;\n            }\n            else {\n                // cause an error by calling it directly.\n                return delegate.apply(window, args);\n            }\n        }; });\n    clearNative =\n        patchMethod(window, cancelName, function (delegate) { return function (self, args) {\n            var task = typeof args[0] === 'number' ? tasksByHandleId[args[0]] : args[0];\n            if (task && typeof task.type === 'string') {\n                if (task.state !== 'notScheduled' &&\n                    (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {\n                    // Do not cancel already canceled functions\n                    task.zone.cancelTask(task);\n                }\n            }\n            else {\n                // cause an error by calling it directly.\n                delegate.apply(window, args);\n            }\n        }; });\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/*\n * This is necessary for Chrome and Chrome mobile, to enable\n * things like redefining `createdCallback` on an element.\n */\nvar _defineProperty = Object[zoneSymbol('defineProperty')] = Object.defineProperty;\nvar _getOwnPropertyDescriptor = Object[zoneSymbol('getOwnPropertyDescriptor')] =\n    Object.getOwnPropertyDescriptor;\nvar _create = Object.create;\nvar unconfigurablesKey = zoneSymbol('unconfigurables');\nfunction propertyPatch() {\n    Object.defineProperty = function (obj, prop, desc) {\n        if (isUnconfigurable(obj, prop)) {\n            throw new TypeError('Cannot assign to read only property \\'' + prop + '\\' of ' + obj);\n        }\n        var originalConfigurableFlag = desc.configurable;\n        if (prop !== 'prototype') {\n            desc = rewriteDescriptor(obj, prop, desc);\n        }\n        return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n    };\n    Object.defineProperties = function (obj, props) {\n        Object.keys(props).forEach(function (prop) {\n            Object.defineProperty(obj, prop, props[prop]);\n        });\n        return obj;\n    };\n    Object.create = function (obj, proto) {\n        if (typeof proto === 'object' && !Object.isFrozen(proto)) {\n            Object.keys(proto).forEach(function (prop) {\n                proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);\n            });\n        }\n        return _create(obj, proto);\n    };\n    Object.getOwnPropertyDescriptor = function (obj, prop) {\n        var desc = _getOwnPropertyDescriptor(obj, prop);\n        if (isUnconfigurable(obj, prop)) {\n            desc.configurable = false;\n        }\n        return desc;\n    };\n}\nfunction _redefineProperty(obj, prop, desc) {\n    var originalConfigurableFlag = desc.configurable;\n    desc = rewriteDescriptor(obj, prop, desc);\n    return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n}\nfunction isUnconfigurable(obj, prop) {\n    return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];\n}\nfunction rewriteDescriptor(obj, prop, desc) {\n    desc.configurable = true;\n    if (!desc.configurable) {\n        if (!obj[unconfigurablesKey]) {\n            _defineProperty(obj, unconfigurablesKey, { writable: true, value: {} });\n        }\n        obj[unconfigurablesKey][prop] = true;\n    }\n    return desc;\n}\nfunction _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {\n    try {\n        return _defineProperty(obj, prop, desc);\n    }\n    catch (error) {\n        if (desc.configurable) {\n            // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let's\n            // retry with the original flag value\n            if (typeof originalConfigurableFlag == 'undefined') {\n                delete desc.configurable;\n            }\n            else {\n                desc.configurable = originalConfigurableFlag;\n            }\n            try {\n                return _defineProperty(obj, prop, desc);\n            }\n            catch (error) {\n                var descJson = null;\n                try {\n                    descJson = JSON.stringify(desc);\n                }\n                catch (error) {\n                    descJson = descJson.toString();\n                }\n                console.log(\"Attempting to configure '\" + prop + \"' with descriptor '\" + descJson + \"' on object '\" + obj + \"' and got error, giving up: \" + error);\n            }\n        }\n        else {\n            throw error;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar WTF_ISSUE_555 = 'Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video';\nvar NO_EVENT_TARGET = 'ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket'\n    .split(',');\nvar EVENT_TARGET = 'EventTarget';\nfunction eventTargetPatch(_global) {\n    var apis = [];\n    var isWtf = _global['wtf'];\n    if (isWtf) {\n        // Workaround for: https://github.com/google/tracing-framework/issues/555\n        apis = WTF_ISSUE_555.split(',').map(function (v) { return 'HTML' + v + 'Element'; }).concat(NO_EVENT_TARGET);\n    }\n    else if (_global[EVENT_TARGET]) {\n        apis.push(EVENT_TARGET);\n    }\n    else {\n        // Note: EventTarget is not available in all browsers,\n        // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget\n        apis = NO_EVENT_TARGET;\n    }\n    for (var i = 0; i < apis.length; i++) {\n        var type = _global[apis[i]];\n        patchEventTargetMethods(type && type.prototype);\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// we have to patch the instance since the proto is non-configurable\nfunction apply(_global) {\n    var WS = _global.WebSocket;\n    // On Safari window.EventTarget doesn't exist so need to patch WS add/removeEventListener\n    // On older Chrome, no need since EventTarget was already patched\n    if (!_global.EventTarget) {\n        patchEventTargetMethods(WS.prototype);\n    }\n    _global.WebSocket = function (a, b) {\n        var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);\n        var proxySocket;\n        // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance\n        var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');\n        if (onmessageDesc && onmessageDesc.configurable === false) {\n            proxySocket = Object.create(socket);\n            ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function (propName) {\n                proxySocket[propName] = function () {\n                    return socket[propName].apply(socket, arguments);\n                };\n            });\n        }\n        else {\n            // we can patch the real socket\n            proxySocket = socket;\n        }\n        patchOnProperties(proxySocket, ['close', 'error', 'message', 'open']);\n        return proxySocket;\n    };\n    for (var prop in WS) {\n        _global['WebSocket'][prop] = WS[prop];\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar globalEventHandlersEventNames = [\n    'abort',\n    'animationcancel',\n    'animationend',\n    'animationiteration',\n    'auxclick',\n    'beforeinput',\n    'blur',\n    'cancel',\n    'canplay',\n    'canplaythrough',\n    'change',\n    'compositionstart',\n    'compositionupdate',\n    'compositionend',\n    'cuechange',\n    'click',\n    'close',\n    'contextmenu',\n    'curechange',\n    'dblclick',\n    'drag',\n    'dragend',\n    'dragenter',\n    'dragexit',\n    'dragleave',\n    'dragover',\n    'drop',\n    'durationchange',\n    'emptied',\n    'ended',\n    'error',\n    'focus',\n    'focusin',\n    'focusout',\n    'gotpointercapture',\n    'input',\n    'invalid',\n    'keydown',\n    'keypress',\n    'keyup',\n    'load',\n    'loadstart',\n    'loadeddata',\n    'loadedmetadata',\n    'lostpointercapture',\n    'mousedown',\n    'mouseenter',\n    'mouseleave',\n    'mousemove',\n    'mouseout',\n    'mouseover',\n    'mouseup',\n    'mousewheel',\n    'pause',\n    'play',\n    'playing',\n    'pointercancel',\n    'pointerdown',\n    'pointerenter',\n    'pointerleave',\n    'pointerlockchange',\n    'mozpointerlockchange',\n    'webkitpointerlockerchange',\n    'pointerlockerror',\n    'mozpointerlockerror',\n    'webkitpointerlockerror',\n    'pointermove',\n    'pointout',\n    'pointerover',\n    'pointerup',\n    'progress',\n    'ratechange',\n    'reset',\n    'resize',\n    'scroll',\n    'seeked',\n    'seeking',\n    'select',\n    'selectionchange',\n    'selectstart',\n    'show',\n    'sort',\n    'stalled',\n    'submit',\n    'suspend',\n    'timeupdate',\n    'volumechange',\n    'touchcancel',\n    'touchmove',\n    'touchstart',\n    'transitioncancel',\n    'transitionend',\n    'waiting',\n    'wheel'\n];\nvar documentEventNames = [\n    'afterscriptexecute', 'beforescriptexecute', 'DOMContentLoaded', 'fullscreenchange',\n    'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange', 'fullscreenerror',\n    'mozfullscreenerror', 'webkitfullscreenerror', 'msfullscreenerror', 'readystatechange'\n];\nvar windowEventNames = [\n    'absolutedeviceorientation',\n    'afterinput',\n    'afterprint',\n    'appinstalled',\n    'beforeinstallprompt',\n    'beforeprint',\n    'beforeunload',\n    'devicelight',\n    'devicemotion',\n    'deviceorientation',\n    'deviceorientationabsolute',\n    'deviceproximity',\n    'hashchange',\n    'languagechange',\n    'message',\n    'mozbeforepaint',\n    'offline',\n    'online',\n    'paint',\n    'pageshow',\n    'pagehide',\n    'popstate',\n    'rejectionhandled',\n    'storage',\n    'unhandledrejection',\n    'unload',\n    'userproximity',\n    'vrdisplyconnected',\n    'vrdisplaydisconnected',\n    'vrdisplaypresentchange'\n];\nvar htmlElementEventNames = [\n    'beforecopy', 'beforecut', 'beforepaste', 'copy', 'cut', 'paste', 'dragstart', 'loadend',\n    'animationstart', 'search', 'transitionrun', 'transitionstart', 'webkitanimationend',\n    'webkitanimationiteration', 'webkitanimationstart', 'webkittransitionend'\n];\nvar mediaElementEventNames = ['encrypted', 'waitingforkey', 'msneedkey', 'mozinterruptbegin', 'mozinterruptend'];\nvar ieElementEventNames = [\n    'activate',\n    'afterupdate',\n    'ariarequest',\n    'beforeactivate',\n    'beforedeactivate',\n    'beforeeditfocus',\n    'beforeupdate',\n    'cellchange',\n    'controlselect',\n    'dataavailable',\n    'datasetchanged',\n    'datasetcomplete',\n    'errorupdate',\n    'filterchange',\n    'layoutcomplete',\n    'losecapture',\n    'move',\n    'moveend',\n    'movestart',\n    'propertychange',\n    'resizeend',\n    'resizestart',\n    'rowenter',\n    'rowexit',\n    'rowsdelete',\n    'rowsinserted',\n    'command',\n    'compassneedscalibration',\n    'deactivate',\n    'help',\n    'mscontentzoom',\n    'msmanipulationstatechanged',\n    'msgesturechange',\n    'msgesturedoubletap',\n    'msgestureend',\n    'msgesturehold',\n    'msgesturestart',\n    'msgesturetap',\n    'msgotpointercapture',\n    'msinertiastart',\n    'mslostpointercapture',\n    'mspointercancel',\n    'mspointerdown',\n    'mspointerenter',\n    'mspointerhover',\n    'mspointerleave',\n    'mspointermove',\n    'mspointerout',\n    'mspointerover',\n    'mspointerup',\n    'pointerout',\n    'mssitemodejumplistitemremoved',\n    'msthumbnailclick',\n    'stop',\n    'storagecommit'\n];\nvar webglEventNames = ['webglcontextrestored', 'webglcontextlost', 'webglcontextcreationerror'];\nvar formEventNames = ['autocomplete', 'autocompleteerror'];\nvar detailEventNames = ['toggle'];\nvar frameEventNames = ['load'];\nvar frameSetEventNames = ['blur', 'error', 'focus', 'load', 'resize', 'scroll'];\nvar marqueeEventNames = ['bounce', 'finish', 'start'];\nvar XMLHttpRequestEventNames = [\n    'loadstart', 'progress', 'abort', 'error', 'load', 'progress', 'timeout', 'loadend',\n    'readystatechange'\n];\nvar IDBIndexEventNames = ['upgradeneeded', 'complete', 'abort', 'success', 'error', 'blocked', 'versionchange', 'close'];\nvar websocketEventNames = ['close', 'error', 'open', 'message'];\nvar eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);\nfunction propertyDescriptorPatch(_global) {\n    if (isNode && !isMix) {\n        return;\n    }\n    var supportsWebSocket = typeof WebSocket !== 'undefined';\n    if (canPatchViaPropertyDescriptor()) {\n        // for browsers that we can patch the descriptor:  Chrome & Firefox\n        if (isBrowser) {\n            // in IE/Edge, onProp not exist in window object, but in WindowPrototype\n            // so we need to pass WindowPrototype to check onProp exist or not\n            patchOnProperties(window, eventNames, Object.getPrototypeOf(window));\n            patchOnProperties(Document.prototype, eventNames);\n            if (typeof window['SVGElement'] !== 'undefined') {\n                patchOnProperties(window['SVGElement'].prototype, eventNames);\n            }\n            patchOnProperties(Element.prototype, eventNames);\n            patchOnProperties(HTMLElement.prototype, eventNames);\n            patchOnProperties(HTMLMediaElement.prototype, mediaElementEventNames);\n            patchOnProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames));\n            patchOnProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames));\n            patchOnProperties(HTMLFrameElement.prototype, frameEventNames);\n            patchOnProperties(HTMLIFrameElement.prototype, frameEventNames);\n            var HTMLMarqueeElement_1 = window['HTMLMarqueeElement'];\n            if (HTMLMarqueeElement_1) {\n                patchOnProperties(HTMLMarqueeElement_1.prototype, marqueeEventNames);\n            }\n        }\n        patchOnProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames);\n        var XMLHttpRequestEventTarget = _global['XMLHttpRequestEventTarget'];\n        if (XMLHttpRequestEventTarget) {\n            patchOnProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames);\n        }\n        if (typeof IDBIndex !== 'undefined') {\n            patchOnProperties(IDBIndex.prototype, IDBIndexEventNames);\n            patchOnProperties(IDBRequest.prototype, IDBIndexEventNames);\n            patchOnProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames);\n            patchOnProperties(IDBDatabase.prototype, IDBIndexEventNames);\n            patchOnProperties(IDBTransaction.prototype, IDBIndexEventNames);\n            patchOnProperties(IDBCursor.prototype, IDBIndexEventNames);\n        }\n        if (supportsWebSocket) {\n            patchOnProperties(WebSocket.prototype, websocketEventNames);\n        }\n    }\n    else {\n        // Safari, Android browsers (Jelly Bean)\n        patchViaCapturingAllTheEvents();\n        patchClass('XMLHttpRequest');\n        if (supportsWebSocket) {\n            apply(_global);\n        }\n    }\n}\nfunction canPatchViaPropertyDescriptor() {\n    if ((isBrowser || isMix) && !Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') &&\n        typeof Element !== 'undefined') {\n        // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364\n        // IDL interface attributes are not configurable\n        var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');\n        if (desc && !desc.configurable)\n            return false;\n    }\n    var xhrDesc = Object.getOwnPropertyDescriptor(XMLHttpRequest.prototype, 'onreadystatechange');\n    // add enumerable and configurable here because in opera\n    // by default XMLHttpRequest.prototype.onreadystatechange is undefined\n    // without adding enumerable and configurable will cause onreadystatechange\n    // non-configurable\n    // and if XMLHttpRequest.prototype.onreadystatechange is undefined,\n    // we should set a real desc instead a fake one\n    if (xhrDesc) {\n        Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n                return true;\n            }\n        });\n        var req = new XMLHttpRequest();\n        var result = !!req.onreadystatechange;\n        // restore original desc\n        Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', xhrDesc || {});\n        return result;\n    }\n    else {\n        Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n                return this[zoneSymbol('fakeonreadystatechange')];\n            },\n            set: function (value) {\n                this[zoneSymbol('fakeonreadystatechange')] = value;\n            }\n        });\n        var req = new XMLHttpRequest();\n        var detectFunc = function () { };\n        req.onreadystatechange = detectFunc;\n        var result = req[zoneSymbol('fakeonreadystatechange')] === detectFunc;\n        req.onreadystatechange = null;\n        return result;\n    }\n}\n\nvar unboundKey = zoneSymbol('unbound');\n// Whenever any eventListener fires, we check the eventListener target and all parents\n// for `onwhatever` properties and replace them with zone-bound functions\n// - Chrome (for now)\nfunction patchViaCapturingAllTheEvents() {\n    var _loop_1 = function (i) {\n        var property = eventNames[i];\n        var onproperty = 'on' + property;\n        self.addEventListener(property, function (event) {\n            var elt = event.target, bound, source;\n            if (elt) {\n                source = elt.constructor['name'] + '.' + onproperty;\n            }\n            else {\n                source = 'unknown.' + onproperty;\n            }\n            while (elt) {\n                if (elt[onproperty] && !elt[onproperty][unboundKey]) {\n                    bound = Zone.current.wrap(elt[onproperty], source);\n                    bound[unboundKey] = elt[onproperty];\n                    elt[onproperty] = bound;\n                }\n                elt = elt.parentElement;\n            }\n        }, true);\n    };\n    for (var i = 0; i < eventNames.length; i++) {\n        _loop_1(i);\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction registerElementPatch(_global) {\n    if ((!isBrowser && !isMix) || !('registerElement' in _global.document)) {\n        return;\n    }\n    var _registerElement = document.registerElement;\n    var callbacks = ['createdCallback', 'attachedCallback', 'detachedCallback', 'attributeChangedCallback'];\n    document.registerElement = function (name, opts) {\n        if (opts && opts.prototype) {\n            callbacks.forEach(function (callback) {\n                var source = 'Document.registerElement::' + callback;\n                if (opts.prototype.hasOwnProperty(callback)) {\n                    var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);\n                    if (descriptor && descriptor.value) {\n                        descriptor.value = Zone.current.wrap(descriptor.value, source);\n                        _redefineProperty(opts.prototype, callback, descriptor);\n                    }\n                    else {\n                        opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);\n                    }\n                }\n                else if (opts.prototype[callback]) {\n                    opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);\n                }\n            });\n        }\n        return _registerElement.apply(document, [name, opts]);\n    };\n    attachOriginToPatched(document.registerElement, _registerElement);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('timers', function (global, Zone, api) {\n    var set = 'set';\n    var clear = 'clear';\n    patchTimer(global, set, clear, 'Timeout');\n    patchTimer(global, set, clear, 'Interval');\n    patchTimer(global, set, clear, 'Immediate');\n    patchTimer(global, 'request', 'cancel', 'AnimationFrame');\n    patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');\n    patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');\n});\nZone.__load_patch('blocking', function (global, Zone, api) {\n    var blockingMethods = ['alert', 'prompt', 'confirm'];\n    for (var i = 0; i < blockingMethods.length; i++) {\n        var name_1 = blockingMethods[i];\n        patchMethod(global, name_1, function (delegate, symbol, name) {\n            return function (s, args) {\n                return Zone.current.run(delegate, global, args, name);\n            };\n        });\n    }\n});\nZone.__load_patch('EventTarget', function (global, Zone, api) {\n    eventTargetPatch(global);\n    // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener\n    var XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];\n    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\n        patchEventTargetMethods(XMLHttpRequestEventTarget.prototype);\n    }\n    patchClass('MutationObserver');\n    patchClass('WebKitMutationObserver');\n    patchClass('FileReader');\n});\nZone.__load_patch('on_property', function (global, Zone, api) {\n    propertyDescriptorPatch(global);\n    propertyPatch();\n    registerElementPatch(global);\n});\nZone.__load_patch('XHR', function (global, Zone, api) {\n    // Treat XMLHTTPRequest as a macrotask.\n    patchXHR(global);\n    var XHR_TASK = zoneSymbol('xhrTask');\n    var XHR_SYNC = zoneSymbol('xhrSync');\n    var XHR_LISTENER = zoneSymbol('xhrListener');\n    var XHR_SCHEDULED = zoneSymbol('xhrScheduled');\n    function patchXHR(window) {\n        function findPendingTask(target) {\n            var pendingTask = target[XHR_TASK];\n            return pendingTask;\n        }\n        function scheduleTask(task) {\n            XMLHttpRequest[XHR_SCHEDULED] = false;\n            var data = task.data;\n            // remove existing event listener\n            var listener = data.target[XHR_LISTENER];\n            if (listener) {\n                data.target.removeEventListener('readystatechange', listener);\n            }\n            var newListener = data.target[XHR_LISTENER] = function () {\n                if (data.target.readyState === data.target.DONE) {\n                    // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with\n                    // readyState=4 multiple times, so we need to check task state here\n                    if (!data.aborted && XMLHttpRequest[XHR_SCHEDULED] &&\n                        task.state === 'scheduled') {\n                        task.invoke();\n                    }\n                }\n            };\n            data.target.addEventListener('readystatechange', newListener);\n            var storedTask = data.target[XHR_TASK];\n            if (!storedTask) {\n                data.target[XHR_TASK] = task;\n            }\n            sendNative.apply(data.target, data.args);\n            XMLHttpRequest[XHR_SCHEDULED] = true;\n            return task;\n        }\n        function placeholderCallback() { }\n        function clearTask(task) {\n            var data = task.data;\n            // Note - ideally, we would call data.target.removeEventListener here, but it's too late\n            // to prevent it from firing. So instead, we store info for the event listener.\n            data.aborted = true;\n            return abortNative.apply(data.target, data.args);\n        }\n        var openNative = patchMethod(window.XMLHttpRequest.prototype, 'open', function () { return function (self, args) {\n            self[XHR_SYNC] = args[2] == false;\n            return openNative.apply(self, args);\n        }; });\n        var sendNative = patchMethod(window.XMLHttpRequest.prototype, 'send', function () { return function (self, args) {\n            var zone = Zone.current;\n            if (self[XHR_SYNC]) {\n                // if the XHR is sync there is no task to schedule, just execute the code.\n                return sendNative.apply(self, args);\n            }\n            else {\n                var options = { target: self, isPeriodic: false, delay: null, args: args, aborted: false };\n                return zone.scheduleMacroTask('XMLHttpRequest.send', placeholderCallback, options, scheduleTask, clearTask);\n            }\n        }; });\n        var abortNative = patchMethod(window.XMLHttpRequest.prototype, 'abort', function (delegate) { return function (self, args) {\n            var task = findPendingTask(self);\n            if (task && typeof task.type == 'string') {\n                // If the XHR has already completed, do nothing.\n                // If the XHR has already been aborted, do nothing.\n                // Fix #569, call abort multiple times before done will cause\n                // macroTask task count be negative number\n                if (task.cancelFn == null || (task.data && task.data.aborted)) {\n                    return;\n                }\n                task.zone.cancelTask(task);\n            }\n            // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no\n            // task\n            // to cancel. Do nothing.\n        }; });\n    }\n});\nZone.__load_patch('geolocation', function (global, Zone, api) {\n    /// GEO_LOCATION\n    if (global['navigator'] && global['navigator'].geolocation) {\n        patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);\n    }\n});\nZone.__load_patch('PromiseRejectionEvent', function (global, Zone, api) {\n    // handle unhandled promise rejection\n    function findPromiseRejectionHandler(evtName) {\n        return function (e) {\n            var eventTasks = findEventTask(global, evtName);\n            eventTasks.forEach(function (eventTask) {\n                // windows has added unhandledrejection event listener\n                // trigger the event listener\n                var PromiseRejectionEvent = global['PromiseRejectionEvent'];\n                if (PromiseRejectionEvent) {\n                    var evt = new PromiseRejectionEvent(evtName, { promise: e.promise, reason: e.rejection });\n                    eventTask.invoke(evt);\n                }\n            });\n        };\n    }\n    if (global['PromiseRejectionEvent']) {\n        Zone[zoneSymbol('unhandledPromiseRejectionHandler')] =\n            findPromiseRejectionHandler('unhandledrejection');\n        Zone[zoneSymbol('rejectionHandledHandler')] =\n            findPromiseRejectionHandler('rejectionhandled');\n    }\n});\nZone.__load_patch('util', function (global, Zone, api) {\n    api.patchEventTargetMethods = patchEventTargetMethods;\n    api.patchOnProperties = patchOnProperties;\n});\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))\n\n/***/ }),\n\n/***/ \"./src/main/webapp/app/polyfills.ts\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/* tslint:disable */\r\n__webpack_require__(\"./node_modules/reflect-metadata/Reflect.ts\");\r\n__webpack_require__(\"./node_modules/zone.js/dist/zone.js\");\r\n__webpack_require__(\"./src/main/webapp/manifest.webapp\");\r\n\n\n/***/ }),\n\n/***/ \"./src/main/webapp/manifest.webapp\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"manifest.webapp\";\n\n/***/ }),\n\n/***/ 1:\n/***/ (function(module, exports) {\n\nmodule.exports = vendor;\n\n/***/ }),\n\n/***/ 16:\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = (__webpack_require__(1))(36);\n\n/***/ }),\n\n/***/ 24:\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = (__webpack_require__(1))(263);\n\n/***/ }),\n\n/***/ 8:\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = (__webpack_require__(1))(27);\n\n/***/ })\n\n},[\"./src/main/webapp/app/polyfills.ts\"]);\n\n\n// WEBPACK FOOTER //\n// app/polyfills.bundle.js","/*! *****************************************************************************\r\nCopyright (C) Microsoft. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\nnamespace Reflect {\r\n    \"use strict\";\r\n\r\n    // Metadata Proposal\r\n    // https://rbuckton.github.io/reflect-metadata/\r\n\r\n    type HashMap<V> = Record<string, V>;\r\n\r\n    interface BufferLike {\r\n        [offset: number]: number;\r\n        length: number;\r\n    }\r\n\r\n    type IteratorResult<T> = { value: T, done: false } | { value: never, done: true };\r\n\r\n    interface Iterator<T> {\r\n        next(value?: any): IteratorResult<T>;\r\n        throw?(value: any): IteratorResult<T>;\r\n        return?(value?: T): IteratorResult<T>;\r\n    }\r\n\r\n    interface Iterable<T> {\r\n        \"@@iterator\"(): Iterator<T>;\r\n    }\r\n\r\n    interface IterableIterator<T> extends Iterator<T> {\r\n        \"@@iterator\"(): IterableIterator<T>;\r\n    }\r\n\r\n    interface Map<K, V> extends Iterable<[K, V]> {\r\n        size: number;\r\n        has(key: K): boolean;\r\n        get(key: K): V;\r\n        set(key: K, value?: V): this;\r\n        delete(key: K): boolean;\r\n        clear(): void;\r\n        keys(): IterableIterator<K>;\r\n        values(): IterableIterator<V>;\r\n        entries(): IterableIterator<[K, V]>;\r\n    }\r\n\r\n    interface MapConstructor {\r\n        new (): Map<any, any>;\r\n        new <K, V>(): Map<K, V>;\r\n        prototype: Map<any, any>;\r\n    }\r\n\r\n    interface Set<T> extends Iterable<T> {\r\n        size: number;\r\n        has(value: T): boolean;\r\n        add(value: T): this;\r\n        delete(value: T): boolean;\r\n        clear(): void;\r\n        keys(): IterableIterator<T>;\r\n        values(): IterableIterator<T>;\r\n        entries(): IterableIterator<[T, T]>;\r\n    }\r\n\r\n    interface SetConstructor {\r\n        new (): Set<any>;\r\n        new <T>(): Set<T>;\r\n        prototype: Set<any>;\r\n    }\r\n\r\n    interface WeakMap<K, V> {\r\n        clear(): void;\r\n        delete(key: K): boolean;\r\n        get(key: K): V;\r\n        has(key: K): boolean;\r\n        set(key: K, value?: V): WeakMap<K, V>;\r\n    }\r\n\r\n    interface WeakMapConstructor {\r\n        new (): WeakMap<any, any>;\r\n        new <K, V>(): WeakMap<K, V>;\r\n        prototype: WeakMap<any, any>;\r\n    }\r\n\r\n    type MemberDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor?: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;\r\n\r\n    declare const Symbol: { iterator: symbol, toPrimitive: symbol };\r\n    declare const Set: SetConstructor;\r\n    declare const WeakMap: WeakMapConstructor;\r\n    declare const Map: MapConstructor;\r\n    declare const global: any;\r\n    declare const crypto: Crypto;\r\n    declare const msCrypto: Crypto;\r\n    declare const process: any;\r\n\r\n    const hasOwn = Object.prototype.hasOwnProperty;\r\n\r\n    // feature test for Symbol support\r\n    const supportsSymbol = typeof Symbol === \"function\";\r\n    const toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== \"undefined\" ? Symbol.toPrimitive : \"@@toPrimitive\";\r\n    const iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\r\n\r\n    namespace HashMap {\r\n        const supportsCreate = typeof Object.create === \"function\"; // feature test for Object.create support\r\n        const supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support\r\n        const downLevel = !supportsCreate && !supportsProto;\r\n\r\n        // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\r\n        export const create = supportsCreate\r\n            ? <V>() => MakeDictionary(Object.create(null) as HashMap<V>)\r\n            : supportsProto\r\n                ? <V>() => MakeDictionary({ __proto__: null as any } as HashMap<V>)\r\n                : <V>() => MakeDictionary({} as HashMap<V>);\r\n\r\n        export const has = downLevel\r\n            ? <V>(map: HashMap<V>, key: string | number | symbol) => hasOwn.call(map, key)\r\n            : <V>(map: HashMap<V>, key: string | number | symbol) => key in map;\r\n\r\n        export const get = downLevel\r\n            ? <V>(map: HashMap<V>, key: string | number | symbol): V | undefined => hasOwn.call(map, key) ? map[key] : undefined\r\n            : <V>(map: HashMap<V>, key: string | number | symbol): V | undefined => map[key];\r\n    }\r\n\r\n    // Load global or shim versions of Map, Set, and WeakMap\r\n    const functionPrototype = Object.getPrototypeOf(Function);\r\n    const usePolyfill = typeof process === \"object\" && process.env && process.env[\"REFLECT_METADATA_USE_MAP_POLYFILL\"] === \"true\";\r\n    const _Map: typeof Map = !usePolyfill && typeof Map === \"function\" && typeof Map.prototype.entries === \"function\" ? Map : CreateMapPolyfill();\r\n    const _Set: typeof Set = !usePolyfill && typeof Set === \"function\" && typeof Set.prototype.entries === \"function\" ? Set : CreateSetPolyfill();\r\n    const _WeakMap: typeof WeakMap = !usePolyfill && typeof WeakMap === \"function\" ? WeakMap : CreateWeakMapPolyfill();\r\n\r\n    // [[Metadata]] internal slot\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots\r\n    const Metadata = new _WeakMap<any, Map<string | symbol | undefined, Map<any, any>>>();\r\n\r\n    /**\r\n      * Applies a set of decorators to a target object.\r\n      * @param decorators An array of decorators.\r\n      * @param target The target object.\r\n      * @returns The result of applying the provided decorators.\r\n      * @remarks Decorators are applied in reverse order of their positions in the array.\r\n      * @example\r\n      *\r\n      *     class Example { }\r\n      *\r\n      *     // constructor\r\n      *     Example = Reflect.decorate(decoratorsArray, Example);\r\n      *\r\n      */\r\n    export function decorate(decorators: ClassDecorator[], target: Function): Function;\r\n\r\n    /**\r\n      * Applies a set of decorators to a property of a target object.\r\n      * @param decorators An array of decorators.\r\n      * @param target The target object.\r\n      * @param propertyKey The property key to decorate.\r\n      * @param attributes A property descriptor.\r\n      * @remarks Decorators are applied in reverse order.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         static staticMethod() { }\r\n      *         method() { }\r\n      *     }\r\n      *\r\n      *     // property (on constructor)\r\n      *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     Object.defineProperty(Example, \"staticMethod\",\r\n      *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\r\n      *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\r\n      *\r\n      *     // method (on prototype)\r\n      *     Object.defineProperty(Example.prototype, \"method\",\r\n      *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\r\n      *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\r\n      *\r\n      */\r\n    export function decorate(decorators: (PropertyDecorator | MethodDecorator)[], target: any, propertyKey: string | symbol, attributes?: PropertyDescriptor | null): PropertyDescriptor | undefined;\r\n\r\n    /**\r\n      * Applies a set of decorators to a property of a target object.\r\n      * @param decorators An array of decorators.\r\n      * @param target The target object.\r\n      * @param propertyKey The property key to decorate.\r\n      * @param attributes A property descriptor.\r\n      * @remarks Decorators are applied in reverse order.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         static staticMethod() { }\r\n      *         method() { }\r\n      *     }\r\n      *\r\n      *     // property (on constructor)\r\n      *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     Object.defineProperty(Example, \"staticMethod\",\r\n      *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\r\n      *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\r\n      *\r\n      *     // method (on prototype)\r\n      *     Object.defineProperty(Example.prototype, \"method\",\r\n      *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\r\n      *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\r\n      *\r\n      */\r\n    export function decorate(decorators: (PropertyDecorator | MethodDecorator)[], target: any, propertyKey: string | symbol, attributes: PropertyDescriptor): PropertyDescriptor;\r\n\r\n    /**\r\n      * Applies a set of decorators to a property of a target object.\r\n      * @param decorators An array of decorators.\r\n      * @param target The target object.\r\n      * @param propertyKey (Optional) The property key to decorate.\r\n      * @param attributes (Optional) The property descriptor for the target key.\r\n      * @remarks Decorators are applied in reverse order.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     Example = Reflect.decorate(decoratorsArray, Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     Object.defineProperty(Example, \"staticMethod\",\r\n      *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\r\n      *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\r\n      *\r\n      *     // method (on prototype)\r\n      *     Object.defineProperty(Example.prototype, \"method\",\r\n      *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\r\n      *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\r\n      *\r\n      */\r\n    export function decorate(decorators: (ClassDecorator | MemberDecorator)[], target: any, propertyKey?: string | symbol, attributes?: PropertyDescriptor | null): PropertyDescriptor | Function | undefined {\r\n        if (!IsUndefined(propertyKey)) {\r\n            if (!IsArray(decorators)) throw new TypeError();\r\n            if (!IsObject(target)) throw new TypeError();\r\n            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes)) throw new TypeError();\r\n            if (IsNull(attributes)) attributes = undefined;\r\n            propertyKey = ToPropertyKey(propertyKey);\r\n            return DecorateProperty(<MemberDecorator[]>decorators, target, propertyKey, attributes);\r\n        }\r\n        else {\r\n            if (!IsArray(decorators)) throw new TypeError();\r\n            if (!IsConstructor(target)) throw new TypeError();\r\n            return DecorateConstructor(<ClassDecorator[]>decorators, <Function>target);\r\n        }\r\n    }\r\n\r\n    // 4.1.2 Reflect.metadata(metadataKey, metadataValue)\r\n    // https://rbuckton.github.io/reflect-metadata/#reflect.metadata\r\n\r\n    /**\r\n      * A default metadata decorator factory that can be used on a class, class member, or parameter.\r\n      * @param metadataKey The key for the metadata entry.\r\n      * @param metadataValue The value for the metadata entry.\r\n      * @returns A decorator function.\r\n      * @remarks\r\n      * If `metadataKey` is already defined for the target and target key, the\r\n      * metadataValue for that key will be overwritten.\r\n      * @example\r\n      *\r\n      *     // constructor\r\n      *     @Reflect.metadata(key, value)\r\n      *     class Example {\r\n      *     }\r\n      *\r\n      *     // property (on constructor, TypeScript only)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         static staticProperty;\r\n      *     }\r\n      *\r\n      *     // property (on prototype, TypeScript only)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         property;\r\n      *     }\r\n      *\r\n      *     // method (on constructor)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         static staticMethod() { }\r\n      *     }\r\n      *\r\n      *     // method (on prototype)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         method() { }\r\n      *     }\r\n      *\r\n      */\r\n    export function metadata(metadataKey: any, metadataValue: any) {\r\n        function decorator(target: Function): void;\r\n        function decorator(target: any, propertyKey: string | symbol): void;\r\n        function decorator(target: any, propertyKey?: string | symbol): void {\r\n            if (!IsObject(target)) throw new TypeError();\r\n            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) throw new TypeError();\r\n            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\r\n        }\r\n        return decorator;\r\n    }\r\n\r\n    // 4.1.3 Reflect.defineMetadata(metadataKey, metadataValue, target [, propertyKey])\r\n    // https://rbuckton.github.io/reflect-metadata/#reflect.definemetadata\r\n\r\n    /**\r\n      * Define a unique metadata entry on the target.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param metadataValue A value that contains attached metadata.\r\n      * @param target The target object on which to define metadata.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\r\n      *\r\n      *     // decorator factory as metadata-producing annotation.\r\n      *     function MyAnnotation(options): ClassDecorator {\r\n      *         return target => Reflect.defineMetadata(\"custom:annotation\", options, target);\r\n      *     }\r\n      *\r\n      */\r\n    export function defineMetadata(metadataKey: any, metadataValue: any, target: any): void;\r\n\r\n    /**\r\n      * Define a unique metadata entry on the target.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param metadataValue A value that contains attached metadata.\r\n      * @param target The target object on which to define metadata.\r\n      * @param propertyKey The property key for the target.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // property (on constructor)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", Number, Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", Number, Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", Number, Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", Number, Example.prototype, \"method\");\r\n      *\r\n      *     // decorator factory as metadata-producing annotation.\r\n      *     function MyAnnotation(options): PropertyDecorator {\r\n      *         return (target, key) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\r\n      *     }\r\n      *\r\n      */\r\n    export function defineMetadata(metadataKey: any, metadataValue: any, target: any, propertyKey: string | symbol): void;\r\n\r\n    /**\r\n      * Define a unique metadata entry on the target.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param metadataValue A value that contains attached metadata.\r\n      * @param target The target object on which to define metadata.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\r\n      *\r\n      *     // decorator factory as metadata-producing annotation.\r\n      *     function MyAnnotation(options): Decorator {\r\n      *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\r\n      *     }\r\n      *\r\n      */\r\n    export function defineMetadata(metadataKey: any, metadataValue: any, target: any, propertyKey?: string | symbol): void {\r\n        if (!IsObject(target)) throw new TypeError();\r\n        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\r\n    }\r\n\r\n    // 4.1.4 Reflect.hasMetadata(metadataKey, target [, propertyKey])\r\n    // https://rbuckton.github.io/reflect-metadata/#reflect.hasmetadata\r\n\r\n    /**\r\n      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\r\n      *\r\n      */\r\n    export function hasMetadata(metadataKey: any, target: any): boolean;\r\n\r\n    /**\r\n      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey The property key for the target.\r\n      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function hasMetadata(metadataKey: any, target: any, propertyKey: string | symbol): boolean;\r\n\r\n    /**\r\n      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function hasMetadata(metadataKey: any, target: any, propertyKey?: string | symbol): boolean {\r\n        if (!IsObject(target)) throw new TypeError();\r\n        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryHasMetadata(metadataKey, target, propertyKey);\r\n    }\r\n\r\n    // 4.1.5 Reflect.hasOwnMetadata(metadataKey, target [, propertyKey])\r\n    // https://rbuckton.github.io/reflect-metadata/#reflect-hasownmetadata\r\n\r\n    /**\r\n      * Gets a value indicating whether the target object has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\r\n      *\r\n      */\r\n    export function hasOwnMetadata(metadataKey: any, target: any): boolean;\r\n\r\n    /**\r\n      * Gets a value indicating whether the target object has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey The property key for the target.\r\n      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function hasOwnMetadata(metadataKey: any, target: any, propertyKey: string | symbol): boolean;\r\n\r\n    /**\r\n      * Gets a value indicating whether the target object has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function hasOwnMetadata(metadataKey: any, target: any, propertyKey?: string | symbol): boolean {\r\n        if (!IsObject(target)) throw new TypeError();\r\n        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);\r\n    }\r\n\r\n    // 4.1.6 Reflect.getMetadata(metadataKey, target [, propertyKey])\r\n    // https://rbuckton.github.io/reflect-metadata/#reflect-getmetadata\r\n\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example);\r\n      *\r\n      */\r\n    export function getMetadata(metadataKey: any, target: any): any;\r\n\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey The property key for the target.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function getMetadata(metadataKey: any, target: any, propertyKey: string | symbol): any;\r\n\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function getMetadata(metadataKey: any, target: any, propertyKey?: string | symbol): any {\r\n        if (!IsObject(target)) throw new TypeError();\r\n        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryGetMetadata(metadataKey, target, propertyKey);\r\n    }\r\n\r\n    // 4.1.7 Reflect.getOwnMetadata(metadataKey, target [, propertyKey])\r\n    // https://rbuckton.github.io/reflect-metadata/#reflect-getownmetadata\r\n\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\r\n      *\r\n      */\r\n    export function getOwnMetadata(metadataKey: any, target: any): any;\r\n\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey The property key for the target.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function getOwnMetadata(metadataKey: any, target: any, propertyKey: string | symbol): any;\r\n\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function getOwnMetadata(metadataKey: any, target: any, propertyKey?: string | symbol): any {\r\n        if (!IsObject(target)) throw new TypeError();\r\n        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);\r\n    }\r\n\r\n    // 4.1.8 Reflect.getMetadataKeys(target [, propertyKey])\r\n    // https://rbuckton.github.io/reflect-metadata/#reflect-getmetadatakeys\r\n\r\n    /**\r\n      * Gets the metadata keys defined on the target object or its prototype chain.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getMetadataKeys(Example);\r\n      *\r\n      */\r\n    export function getMetadataKeys(target: any): any[];\r\n\r\n    /**\r\n      * Gets the metadata keys defined on the target object or its prototype chain.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey The property key for the target.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function getMetadataKeys(target: any, propertyKey: string | symbol): any[];\r\n\r\n    /**\r\n      * Gets the metadata keys defined on the target object or its prototype chain.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getMetadataKeys(Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function getMetadataKeys(target: any, propertyKey?: string | symbol): any[] {\r\n        if (!IsObject(target)) throw new TypeError();\r\n        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryMetadataKeys(target, propertyKey);\r\n    }\r\n\r\n    // 4.1.9 Reflect.getOwnMetadataKeys(target [, propertyKey])\r\n    // https://rbuckton.github.io/reflect-metadata/#reflect-getownmetadata\r\n\r\n    /**\r\n      * Gets the unique metadata keys defined on the target object.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getOwnMetadataKeys(Example);\r\n      *\r\n      */\r\n    export function getOwnMetadataKeys(target: any): any[];\r\n\r\n    /**\r\n      * Gets the unique metadata keys defined on the target object.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey The property key for the target.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function getOwnMetadataKeys(target: any, propertyKey: string | symbol): any[];\r\n\r\n    /**\r\n      * Gets the unique metadata keys defined on the target object.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getOwnMetadataKeys(Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function getOwnMetadataKeys(target: any, propertyKey?: string | symbol): any[] {\r\n        if (!IsObject(target)) throw new TypeError();\r\n        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\r\n        return OrdinaryOwnMetadataKeys(target, propertyKey);\r\n    }\r\n\r\n    // 4.1.10 Reflect.deleteMetadata(metadataKey, target [, propertyKey])\r\n    // https://rbuckton.github.io/reflect-metadata/#reflect-deletemetadata\r\n\r\n    /**\r\n      * Deletes the metadata entry from the target object with the provided key.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @returns `true` if the metadata entry was found and deleted; otherwise, false.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\r\n      *\r\n      */\r\n    export function deleteMetadata(metadataKey: any, target: any): boolean;\r\n\r\n    /**\r\n      * Deletes the metadata entry from the target object with the provided key.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey The property key for the target.\r\n      * @returns `true` if the metadata entry was found and deleted; otherwise, false.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function deleteMetadata(metadataKey: any, target: any, propertyKey: string | symbol): boolean;\r\n\r\n    /**\r\n      * Deletes the metadata entry from the target object with the provided key.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param propertyKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata entry was found and deleted; otherwise, false.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    export function deleteMetadata(metadataKey: any, target: any, propertyKey?: string | symbol): boolean {\r\n        if (!IsObject(target)) throw new TypeError();\r\n        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\r\n        const metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);\r\n        if (IsUndefined(metadataMap)) return false;\r\n        if (!metadataMap.delete(metadataKey)) return false;\r\n        if (metadataMap.size > 0) return true;\r\n        const targetMetadata = Metadata.get(target);\r\n        targetMetadata.delete(propertyKey);\r\n        if (targetMetadata.size > 0) return true;\r\n        Metadata.delete(target);\r\n        return true;\r\n    }\r\n\r\n    function DecorateConstructor(decorators: ClassDecorator[], target: Function): Function {\r\n        for (let i = decorators.length - 1; i >= 0; --i) {\r\n            const decorator = decorators[i];\r\n            const decorated = decorator(target);\r\n            if (!IsUndefined(decorated) && !IsNull(decorated)) {\r\n                if (!IsConstructor(decorated)) throw new TypeError();\r\n                target = <Function>decorated;\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    function DecorateProperty(decorators: MemberDecorator[], target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor | undefined): PropertyDescriptor | undefined {\r\n        for (let i = decorators.length - 1; i >= 0; --i) {\r\n            const decorator = decorators[i];\r\n            const decorated = decorator(target, propertyKey, descriptor);\r\n            if (!IsUndefined(decorated) && !IsNull(decorated)) {\r\n                if (!IsObject(decorated)) throw new TypeError();\r\n                descriptor = <PropertyDescriptor>decorated;\r\n            }\r\n        }\r\n        return descriptor;\r\n    }\r\n\r\n    // 2.1.1 GetOrCreateMetadataMap(O, P, Create)\r\n    // https://rbuckton.github.io/reflect-metadata/#getorcreatemetadatamap\r\n    function GetOrCreateMetadataMap(O: any, P: string | symbol | undefined, Create: true): Map<any, any>;\r\n    function GetOrCreateMetadataMap(O: any, P: string | symbol | undefined, Create: false): Map<any, any> | undefined;\r\n    function GetOrCreateMetadataMap(O: any, P: string | symbol | undefined, Create: boolean): Map<any, any> | undefined {\r\n        let targetMetadata = Metadata.get(O);\r\n        if (IsUndefined(targetMetadata)) {\r\n            if (!Create) return undefined;\r\n            targetMetadata = new _Map<string | symbol | undefined, Map<any, any>>();\r\n            Metadata.set(O, targetMetadata);\r\n        }\r\n        let metadataMap = targetMetadata.get(P);\r\n        if (IsUndefined(metadataMap)) {\r\n            if (!Create) return undefined;\r\n            metadataMap = new _Map<any, any>();\r\n            targetMetadata.set(P, metadataMap);\r\n        }\r\n        return metadataMap;\r\n    }\r\n\r\n    // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata\r\n    function OrdinaryHasMetadata(MetadataKey: any, O: any, P: string | symbol | undefined): boolean {\r\n        const hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n        if (hasOwn) return true;\r\n        const parent = OrdinaryGetPrototypeOf(O);\r\n        if (!IsNull(parent)) return OrdinaryHasMetadata(MetadataKey, parent, P);\r\n        return false;\r\n    }\r\n\r\n    // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\r\n    function OrdinaryHasOwnMetadata(MetadataKey: any, O: any, P: string | symbol | undefined): boolean {\r\n        const metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\r\n        if (IsUndefined(metadataMap)) return false;\r\n        return ToBoolean(metadataMap.has(MetadataKey));\r\n    }\r\n\r\n    // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata\r\n    function OrdinaryGetMetadata(MetadataKey: any, O: any, P: string | symbol | undefined): any {\r\n        const hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n        if (hasOwn) return OrdinaryGetOwnMetadata(MetadataKey, O, P);\r\n        const parent = OrdinaryGetPrototypeOf(O);\r\n        if (!IsNull(parent)) return OrdinaryGetMetadata(MetadataKey, parent, P);\r\n        return undefined;\r\n    }\r\n\r\n    // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\r\n    function OrdinaryGetOwnMetadata(MetadataKey: any, O: any, P: string | symbol | undefined): any {\r\n        const metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\r\n        if (IsUndefined(metadataMap)) return undefined;\r\n        return metadataMap.get(MetadataKey);\r\n    }\r\n\r\n    // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\r\n    function OrdinaryDefineOwnMetadata(MetadataKey: any, MetadataValue: any, O: any, P: string | symbol | undefined): void {\r\n        const metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);\r\n        metadataMap.set(MetadataKey, MetadataValue);\r\n    }\r\n\r\n    // 3.1.6.1 OrdinaryMetadataKeys(O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys\r\n    function OrdinaryMetadataKeys(O: any, P: string | symbol | undefined): any[] {\r\n        const ownKeys = OrdinaryOwnMetadataKeys(O, P);\r\n        const parent = OrdinaryGetPrototypeOf(O);\r\n        if (parent === null) return ownKeys;\r\n        const parentKeys = OrdinaryMetadataKeys(parent, P);\r\n        if (parentKeys.length <= 0) return ownKeys;\r\n        if (ownKeys.length <= 0) return parentKeys;\r\n        const set = new _Set<any>();\r\n        const keys: any[] = [];\r\n        for (const key of ownKeys) {\r\n            const hasKey = set.has(key);\r\n            if (!hasKey) {\r\n                set.add(key);\r\n                keys.push(key);\r\n            }\r\n        }\r\n        for (const key of parentKeys) {\r\n            const hasKey = set.has(key);\r\n            if (!hasKey) {\r\n                set.add(key);\r\n                keys.push(key);\r\n            }\r\n        }\r\n        return keys;\r\n    }\r\n\r\n    // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\r\n    // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\r\n    function OrdinaryOwnMetadataKeys(O: any, P: string | symbol | undefined): any[] {\r\n        const keys: any[] = [];\r\n        const metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\r\n        if (IsUndefined(metadataMap)) return keys;\r\n        const keysObj = metadataMap.keys();\r\n        const iterator = GetIterator(keysObj);\r\n        let k = 0;\r\n        while (true) {\r\n            const next = IteratorStep(iterator);\r\n            if (!next) {\r\n                keys.length = k;\r\n                return keys;\r\n            }\r\n            const nextValue = IteratorValue(next);\r\n            try {\r\n                keys[k] = nextValue;\r\n            }\r\n            catch (e) {\r\n                try {\r\n                    IteratorClose(iterator);\r\n                }\r\n                finally {\r\n                    throw e;\r\n                }\r\n            }\r\n            k++;\r\n        }\r\n    }\r\n\r\n    // 6 ECMAScript Data Typ0es and Values\r\n    // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values\r\n    function Type(x: any): Tag {\r\n        if (x === null) return Tag.Null;\r\n        switch (typeof x) {\r\n            case \"undefined\": return Tag.Undefined;\r\n            case \"boolean\": return Tag.Boolean;\r\n            case \"string\": return Tag.String;\r\n            case \"symbol\": return Tag.Symbol;\r\n            case \"number\": return Tag.Number;\r\n            case \"object\": return x === null ? Tag.Null : Tag.Object;\r\n            default: return Tag.Object;\r\n        }\r\n    }\r\n\r\n    // 6.1 ECMAScript Language Types\r\n    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types\r\n    const enum Tag {\r\n        Undefined,\r\n        Null,\r\n        Boolean,\r\n        String,\r\n        Symbol,\r\n        Number,\r\n        Object\r\n    }\r\n\r\n    // 6.1.1 The Undefined Type\r\n    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type\r\n    function IsUndefined(x: any): x is undefined {\r\n        return x === undefined;\r\n    }\r\n\r\n    // 6.1.2 The Null Type\r\n    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type\r\n    function IsNull(x: any): x is null {\r\n        return x === null;\r\n    }\r\n\r\n    // 6.1.5 The Symbol Type\r\n    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type\r\n    function IsSymbol(x: any): x is symbol {\r\n        return typeof x === \"symbol\";\r\n    }\r\n\r\n    // 6.1.7 The Object Type\r\n    // https://tc39.github.io/ecma262/#sec-object-type\r\n    function IsObject<T>(x: T | undefined | null | boolean | string | symbol | number): x is T {\r\n        return typeof x === \"object\" ? x !== null : typeof x === \"function\";\r\n    }\r\n\r\n    // 7.1 Type Conversion\r\n    // https://tc39.github.io/ecma262/#sec-type-conversion\r\n\r\n    // 7.1.1 ToPrimitive(input [, PreferredType])\r\n    // https://tc39.github.io/ecma262/#sec-toprimitive\r\n    function ToPrimitive(input: any, PreferredType?: Tag): undefined | null | boolean | string | symbol | number {\r\n        switch (Type(input)) {\r\n            case Tag.Undefined: return input;\r\n            case Tag.Null: return input;\r\n            case Tag.Boolean: return input;\r\n            case Tag.String: return input;\r\n            case Tag.Symbol: return input;\r\n            case Tag.Number: return input;\r\n        }\r\n        const hint: \"string\" | \"number\" | \"default\" = PreferredType === Tag.String ? \"string\" : PreferredType === Tag.Number ? \"number\" : \"default\";\r\n        const exoticToPrim = GetMethod(input, toPrimitiveSymbol);\r\n        if (exoticToPrim !== undefined) {\r\n            const result = exoticToPrim.call(input, hint);\r\n            if (IsObject(result)) throw new TypeError();\r\n            return result;\r\n        }\r\n        return OrdinaryToPrimitive(input, hint === \"default\" ? \"number\" : hint);\r\n    }\r\n\r\n    // 7.1.1.1 OrdinaryToPrimitive(O, hint)\r\n    // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive\r\n    function OrdinaryToPrimitive(O: any, hint: \"string\" | \"number\"): undefined | null | boolean | string | symbol | number {\r\n        if (hint === \"string\") {\r\n            const toString = O.toString;\r\n            if (IsCallable(toString)) {\r\n                const result = toString.call(O);\r\n                if (!IsObject(result)) return result;\r\n            }\r\n            const valueOf = O.valueOf;\r\n            if (IsCallable(valueOf)) {\r\n                const result = valueOf.call(O);\r\n                if (!IsObject(result)) return result;\r\n            }\r\n        }\r\n        else {\r\n            const valueOf = O.valueOf;\r\n            if (IsCallable(valueOf)) {\r\n                const result = valueOf.call(O);\r\n                if (!IsObject(result)) return result;\r\n            }\r\n            const toString = O.toString;\r\n            if (IsCallable(toString)) {\r\n                const result = toString.call(O);\r\n                if (!IsObject(result)) return result;\r\n            }\r\n        }\r\n        throw new TypeError();\r\n    }\r\n\r\n    // 7.1.2 ToBoolean(argument)\r\n    // https://tc39.github.io/ecma262/2016/#sec-toboolean\r\n    function ToBoolean(argument: any): boolean {\r\n        return !!argument;\r\n    }\r\n\r\n    // 7.1.12 ToString(argument)\r\n    // https://tc39.github.io/ecma262/#sec-tostring\r\n    function ToString(argument: any): string {\r\n        return \"\" + argument;\r\n    }\r\n\r\n    // 7.1.14 ToPropertyKey(argument)\r\n    // https://tc39.github.io/ecma262/#sec-topropertykey\r\n    function ToPropertyKey(argument: any): string | symbol {\r\n        const key = ToPrimitive(argument, Tag.String);\r\n        if (IsSymbol(key)) return key;\r\n        return ToString(key);\r\n    }\r\n\r\n    // 7.2 Testing and Comparison Operations\r\n    // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations\r\n\r\n    // 7.2.2 IsArray(argument)\r\n    // https://tc39.github.io/ecma262/#sec-isarray\r\n    function IsArray(argument: any): argument is any[] {\r\n        return Array.isArray\r\n            ? Array.isArray(argument)\r\n            : argument instanceof Object\r\n                ? argument instanceof Array\r\n                : Object.prototype.toString.call(argument) === \"[object Array]\";\r\n    }\r\n\r\n    // 7.2.3 IsCallable(argument)\r\n    // https://tc39.github.io/ecma262/#sec-iscallable\r\n    function IsCallable(argument: any): argument is Function {\r\n        // NOTE: This is an approximation as we cannot check for [[Call]] internal method.\r\n        return typeof argument === \"function\";\r\n    }\r\n\r\n    // 7.2.4 IsConstructor(argument)\r\n    // https://tc39.github.io/ecma262/#sec-isconstructor\r\n    function IsConstructor(argument: any): argument is Function {\r\n        // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.\r\n        return typeof argument === \"function\";\r\n    }\r\n\r\n    // 7.2.7 IsPropertyKey(argument)\r\n    // https://tc39.github.io/ecma262/#sec-ispropertykey\r\n    function IsPropertyKey(argument: any): argument is string | symbol {\r\n        switch (Type(argument)) {\r\n            case Tag.String: return true;\r\n            case Tag.Symbol: return true;\r\n            default: return false;\r\n        }\r\n    }\r\n\r\n    // 7.3 Operations on Objects\r\n    // https://tc39.github.io/ecma262/#sec-operations-on-objects\r\n\r\n    // 7.3.9 GetMethod(V, P)\r\n    // https://tc39.github.io/ecma262/#sec-getmethod\r\n    function GetMethod(V: any, P: any): Function | undefined {\r\n        const func = V[P];\r\n        if (func === undefined || func === null) return undefined;\r\n        if (!IsCallable(func)) throw new TypeError();\r\n        return func;\r\n    }\r\n\r\n    // 7.4 Operations on Iterator Objects\r\n    // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects\r\n\r\n    function GetIterator<T>(obj: Iterable<T>): Iterator<T> {\r\n        const method = GetMethod(obj, iteratorSymbol);\r\n        if (!IsCallable(method)) throw new TypeError(); // from Call\r\n        const iterator = method.call(obj);\r\n        if (!IsObject(iterator)) throw new TypeError();\r\n        return iterator;\r\n    }\r\n\r\n    // 7.4.4 IteratorValue(iterResult)\r\n    // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue\r\n    function IteratorValue<T>(iterResult: IteratorResult<T>): T {\r\n        return iterResult.value;\r\n    }\r\n\r\n    // 7.4.5 IteratorStep(iterator)\r\n    // https://tc39.github.io/ecma262/#sec-iteratorstep\r\n    function IteratorStep<T>(iterator: Iterator<T>): IteratorResult<T> | false {\r\n        const result = iterator.next();\r\n        return result.done ? false : result;\r\n    }\r\n\r\n    // 7.4.6 IteratorClose(iterator, completion)\r\n    // https://tc39.github.io/ecma262/#sec-iteratorclose\r\n    function IteratorClose<T>(iterator: Iterator<T>) {\r\n        const f = iterator[\"return\"];\r\n        if (f) f.call(iterator);\r\n    }\r\n\r\n    // 9.1 Ordinary Object Internal Methods and Internal Slots\r\n    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots\r\n\r\n    // 9.1.1.1 OrdinaryGetPrototypeOf(O)\r\n    // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof\r\n    function OrdinaryGetPrototypeOf(O: any): any {\r\n        const proto = Object.getPrototypeOf(O);\r\n        if (typeof O !== \"function\" || O === functionPrototype) return proto;\r\n\r\n        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.\r\n        // Try to determine the superclass constructor. Compatible implementations\r\n        // must either set __proto__ on a subclass constructor to the superclass constructor,\r\n        // or ensure each class has a valid `constructor` property on its prototype that\r\n        // points back to the constructor.\r\n\r\n        // If this is not the same as Function.[[Prototype]], then this is definately inherited.\r\n        // This is the case when in ES6 or when using __proto__ in a compatible browser.\r\n        if (proto !== functionPrototype) return proto;\r\n\r\n        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\r\n        const prototype = O.prototype;\r\n        const prototypeProto = prototype && Object.getPrototypeOf(prototype);\r\n        if (prototypeProto == null || prototypeProto === Object.prototype) return proto;\r\n\r\n        // If the constructor was not a function, then we cannot determine the heritage.\r\n        const constructor = prototypeProto.constructor;\r\n        if (typeof constructor !== \"function\") return proto;\r\n\r\n        // If we have some kind of self-reference, then we cannot determine the heritage.\r\n        if (constructor === O) return proto;\r\n\r\n        // we have a pretty good guess at the heritage.\r\n        return constructor;\r\n    }\r\n\r\n    // naive Map shim\r\n    function CreateMapPolyfill(): MapConstructor {\r\n        const cacheSentinel = {};\r\n        const arraySentinel: any[] = [];\r\n\r\n        class MapIterator<K, V, R extends (K | V | [K, V])> implements IterableIterator<R> {\r\n            private _keys: K[];\r\n            private _values: V[];\r\n            private _index = 0;\r\n            private _selector: (key: K, value: V) => R;\r\n            constructor(keys: K[], values: V[], selector: (key: K, value: V) => R) {\r\n                this._keys = keys;\r\n                this._values = values;\r\n                this._selector = selector;\r\n            }\r\n            \"@@iterator\"() { return this; }\r\n            [iteratorSymbol]() { return this; }\r\n            next(): IteratorResult<R> {\r\n                const index = this._index;\r\n                if (index >= 0 && index < this._keys.length) {\r\n                    const result = this._selector(this._keys[index], this._values[index]);\r\n                    if (index + 1 >= this._keys.length) {\r\n                        this._index = -1;\r\n                        this._keys = arraySentinel;\r\n                        this._values = arraySentinel;\r\n                    }\r\n                    else {\r\n                        this._index++;\r\n                    }\r\n                    return { value: result, done: false };\r\n                }\r\n                return { value: <never>undefined, done: true };\r\n            }\r\n            throw(error: any): IteratorResult<R> {\r\n                if (this._index >= 0) {\r\n                    this._index = -1;\r\n                    this._keys = arraySentinel;\r\n                    this._values = arraySentinel;\r\n                }\r\n                throw error;\r\n            }\r\n            return(value?: R): IteratorResult<R> {\r\n                if (this._index >= 0) {\r\n                    this._index = -1;\r\n                    this._keys = arraySentinel;\r\n                    this._values = arraySentinel;\r\n                }\r\n                return { value: <never>value, done: true };\r\n            }\r\n        }\r\n\r\n        return class Map<K, V> {\r\n            private _keys: K[] = [];\r\n            private _values: (V | undefined)[] = [];\r\n            private _cacheKey = cacheSentinel;\r\n            private _cacheIndex = -2;\r\n            get size() { return this._keys.length; }\r\n            has(key: K): boolean { return this._find(key, /*insert*/ false) >= 0; }\r\n            get(key: K): V | undefined {\r\n                const index = this._find(key, /*insert*/ false);\r\n                return index >= 0 ? this._values[index] : undefined;\r\n            }\r\n            set(key: K, value: V): this {\r\n                const index = this._find(key, /*insert*/ true);\r\n                this._values[index] = value;\r\n                return this;\r\n            }\r\n            delete(key: K): boolean {\r\n                const index = this._find(key, /*insert*/ false);\r\n                if (index >= 0) {\r\n                    const size = this._keys.length;\r\n                    for (let i = index + 1; i < size; i++) {\r\n                        this._keys[i - 1] = this._keys[i];\r\n                        this._values[i - 1] = this._values[i];\r\n                    }\r\n                    this._keys.length--;\r\n                    this._values.length--;\r\n                    if (key === this._cacheKey) {\r\n                        this._cacheKey = cacheSentinel;\r\n                        this._cacheIndex = -2;\r\n                    }\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            clear(): void {\r\n                this._keys.length = 0;\r\n                this._values.length = 0;\r\n                this._cacheKey = cacheSentinel;\r\n                this._cacheIndex = -2;\r\n            }\r\n            keys() { return new MapIterator(this._keys, this._values, getKey); }\r\n            values() { return new MapIterator(this._keys, this._values, getValue); }\r\n            entries() { return new MapIterator(this._keys, this._values, getEntry); }\r\n            \"@@iterator\"() { return this.entries(); }\r\n            [iteratorSymbol]() { return this.entries(); }\r\n            private _find(key: K, insert?: boolean): number {\r\n                if (this._cacheKey !== key) {\r\n                    this._cacheIndex = this._keys.indexOf(this._cacheKey = key);\r\n                }\r\n                if (this._cacheIndex < 0 && insert) {\r\n                    this._cacheIndex = this._keys.length;\r\n                    this._keys.push(key);\r\n                    this._values.push(undefined);\r\n                }\r\n                return this._cacheIndex;\r\n            }\r\n        };\r\n\r\n        function getKey<K, V>(key: K, _: V) {\r\n            return key;\r\n        }\r\n\r\n        function getValue<K, V>(_: K, value: V) {\r\n            return value;\r\n        }\r\n\r\n        function getEntry<K, V>(key: K, value: V) {\r\n            return [key, value] as [K, V];\r\n        }\r\n    }\r\n\r\n    // naive Set shim\r\n    function CreateSetPolyfill(): SetConstructor {\r\n        return class Set<T> {\r\n            private _map = new _Map<any, any>();\r\n            get size() { return this._map.size; }\r\n            has(value: T): boolean { return this._map.has(value); }\r\n            add(value: T): Set<T> { return this._map.set(value, value), this; }\r\n            delete(value: T): boolean { return this._map.delete(value); }\r\n            clear(): void { this._map.clear(); }\r\n            keys() { return this._map.keys(); }\r\n            values() { return this._map.values(); }\r\n            entries() { return this._map.entries(); }\r\n            \"@@iterator\"() { return this.keys(); }\r\n            [iteratorSymbol]() { return this.keys(); }\r\n        };\r\n    }\r\n\r\n    // naive WeakMap shim\r\n    function CreateWeakMapPolyfill(): WeakMapConstructor {\r\n        const UUID_SIZE = 16;\r\n        const keys = HashMap.create<boolean>();\r\n        const rootKey = CreateUniqueKey();\r\n        return class WeakMap<K, V> {\r\n            private _key = CreateUniqueKey();\r\n            has(target: K): boolean {\r\n                const table = GetOrCreateWeakMapTable<K>(target, /*create*/ false);\r\n                return table !== undefined ? HashMap.has(table, this._key) : false;\r\n            }\r\n            get(target: K): V {\r\n                const table = GetOrCreateWeakMapTable<K>(target, /*create*/ false);\r\n                return table !== undefined ? HashMap.get(table, this._key) : undefined;\r\n            }\r\n            set(target: K, value: V): WeakMap<K, V> {\r\n                const table = GetOrCreateWeakMapTable<K>(target, /*create*/ true);\r\n                table[this._key] = value;\r\n                return this;\r\n            }\r\n            delete(target: K): boolean {\r\n                const table = GetOrCreateWeakMapTable<K>(target, /*create*/ false);\r\n                return table !== undefined ? delete table[this._key] : false;\r\n            }\r\n            clear(): void {\r\n                // NOTE: not a real clear, just makes the previous data unreachable\r\n                this._key = CreateUniqueKey();\r\n            }\r\n        };\r\n\r\n        function CreateUniqueKey(): string {\r\n            let key: string;\r\n            do key = \"@@WeakMap@@\" + CreateUUID();\r\n            while (HashMap.has(keys, key));\r\n            keys[key] = true;\r\n            return key;\r\n        }\r\n\r\n        function GetOrCreateWeakMapTable<K>(target: K, create: true): HashMap<any>;\r\n        function GetOrCreateWeakMapTable<K>(target: K, create: false): HashMap<any> | undefined;\r\n        function GetOrCreateWeakMapTable<K>(target: K, create: boolean): HashMap<any> | undefined {\r\n            if (!hasOwn.call(target, rootKey)) {\r\n                if (!create) return undefined;\r\n                Object.defineProperty(target, rootKey, { value: HashMap.create<any>() });\r\n            }\r\n            return (<any>target)[rootKey];\r\n        }\r\n\r\n        function FillRandomBytes(buffer: BufferLike, size: number): BufferLike {\r\n            for (let i = 0; i < size; ++i) buffer[i] = Math.random() * 0xff | 0;\r\n            return buffer;\r\n        }\r\n\r\n        function GenRandomBytes(size: number): BufferLike {\r\n            if (typeof Uint8Array === \"function\") {\r\n                if (typeof crypto !== \"undefined\") return crypto.getRandomValues(new Uint8Array(size)) as Uint8Array;\r\n                if (typeof msCrypto !== \"undefined\") return msCrypto.getRandomValues(new Uint8Array(size)) as Uint8Array;\r\n                return FillRandomBytes(new Uint8Array(size), size);\r\n            }\r\n            return FillRandomBytes(new Array(size), size);\r\n        }\r\n\r\n        function CreateUUID() {\r\n            const data = GenRandomBytes(UUID_SIZE);\r\n            // mark as random - RFC 4122  4.4\r\n            data[6] = data[6] & 0x4f | 0x40;\r\n            data[8] = data[8] & 0xbf | 0x80;\r\n            let result = \"\";\r\n            for (let offset = 0; offset < UUID_SIZE; ++offset) {\r\n                const byte = data[offset];\r\n                if (offset === 4 || offset === 6 || offset === 8) result += \"-\";\r\n                if (byte < 16) result += \"0\";\r\n                result += byte.toString(16).toLowerCase();\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.\r\n    function MakeDictionary<T>(obj: T): T {\r\n        (<any>obj).__ = undefined;\r\n        delete (<any>obj).__;\r\n        return obj;\r\n    }\r\n\r\n    // patch global Reflect\r\n    (function (__global: any) {\r\n        if (typeof __global.Reflect !== \"undefined\") {\r\n            if (__global.Reflect !== Reflect) {\r\n                for (const p in Reflect) {\r\n                    if (hasOwn.call(Reflect, p)) {\r\n                        __global.Reflect[p] = (<any>Reflect)[p];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            __global.Reflect = Reflect;\r\n        }\r\n    })(\r\n        typeof global !== \"undefined\" ? global :\r\n            typeof self !== \"undefined\" ? self :\r\n                Function(\"return this;\")());\r\n}\n\n\n// WEBPACK FOOTER //\n// ./~/reflect-metadata/Reflect.ts","/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(factory());\n}(this, (function () { 'use strict';\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Zone$1 = (function (global) {\n    var performance = global['performance'];\n    function mark(name) {\n        performance && performance['mark'] && performance['mark'](name);\n    }\n    function performanceMeasure(name, label) {\n        performance && performance['measure'] && performance['measure'](name, label);\n    }\n    mark('Zone');\n    if (global['Zone']) {\n        throw new Error('Zone already loaded.');\n    }\n    var Zone = (function () {\n        function Zone(parent, zoneSpec) {\n            this._properties = null;\n            this._parent = parent;\n            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';\n            this._properties = zoneSpec && zoneSpec.properties || {};\n            this._zoneDelegate =\n                new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n        }\n        Zone.assertZonePatched = function () {\n            if (global['Promise'] !== patches['ZoneAwarePromise']) {\n                throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +\n                    'has been overwritten.\\n' +\n                    'Most likely cause is that a Promise polyfill has been loaded ' +\n                    'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +\n                    'If you must load one, do so before loading zone.js.)');\n            }\n        };\n        Object.defineProperty(Zone, \"root\", {\n            get: function () {\n                var zone = Zone.current;\n                while (zone.parent) {\n                    zone = zone.parent;\n                }\n                return zone;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Zone, \"current\", {\n            get: function () {\n                return _currentZoneFrame.zone;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Object.defineProperty(Zone, \"currentTask\", {\n            get: function () {\n                return _currentTask;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Zone.__load_patch = function (name, fn) {\n            if (patches.hasOwnProperty(name)) {\n                throw Error('Already loaded patch: ' + name);\n            }\n            else if (!global['__Zone_disable_' + name]) {\n                var perfName = 'Zone:' + name;\n                mark(perfName);\n                patches[name] = fn(global, Zone, _api);\n                performanceMeasure(perfName, perfName);\n            }\n        };\n        Object.defineProperty(Zone.prototype, \"parent\", {\n            get: function () {\n                return this._parent;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Object.defineProperty(Zone.prototype, \"name\", {\n            get: function () {\n                return this._name;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Zone.prototype.get = function (key) {\n            var zone = this.getZoneWith(key);\n            if (zone)\n                return zone._properties[key];\n        };\n        Zone.prototype.getZoneWith = function (key) {\n            var current = this;\n            while (current) {\n                if (current._properties.hasOwnProperty(key)) {\n                    return current;\n                }\n                current = current._parent;\n            }\n            return null;\n        };\n        Zone.prototype.fork = function (zoneSpec) {\n            if (!zoneSpec)\n                throw new Error('ZoneSpec required!');\n            return this._zoneDelegate.fork(this, zoneSpec);\n        };\n        Zone.prototype.wrap = function (callback, source) {\n            if (typeof callback !== 'function') {\n                throw new Error('Expecting function got: ' + callback);\n            }\n            var _callback = this._zoneDelegate.intercept(this, callback, source);\n            var zone = this;\n            return function () {\n                return zone.runGuarded(_callback, this, arguments, source);\n            };\n        };\n        Zone.prototype.run = function (callback, applyThis, applyArgs, source) {\n            if (applyThis === void 0) { applyThis = undefined; }\n            if (applyArgs === void 0) { applyArgs = null; }\n            if (source === void 0) { source = null; }\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        };\n        Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {\n            if (applyThis === void 0) { applyThis = null; }\n            if (applyArgs === void 0) { applyArgs = null; }\n            if (source === void 0) { source = null; }\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                try {\n                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        };\n        Zone.prototype.runTask = function (task, applyThis, applyArgs) {\n            if (task.zone != this) {\n                throw new Error('A task can only be run in the zone of creation! (Creation: ' +\n                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n            }\n            // https://github.com/angular/zone.js/issues/778, sometimes eventTask\n            // will run in notScheduled(canceled) state, we should not try to\n            // run such kind of task but just return\n            // we have to define an variable here, if not\n            // typescript compiler will complain below\n            var isNotScheduled = task.state === notScheduled;\n            if (isNotScheduled && task.type === eventTask) {\n                return;\n            }\n            var reEntryGuard = task.state != running;\n            reEntryGuard && task._transitionTo(running, scheduled);\n            task.runCount++;\n            var previousTask = _currentTask;\n            _currentTask = task;\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                if (task.type == macroTask && task.data && !task.data.isPeriodic) {\n                    task.cancelFn = null;\n                }\n                try {\n                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                // if the task's state is notScheduled or unknown, then it has already been cancelled\n                // we should not reset the state to scheduled\n                if (task.state !== notScheduled && task.state !== unknown) {\n                    if (task.type == eventTask || (task.data && task.data.isPeriodic)) {\n                        reEntryGuard && task._transitionTo(scheduled, running);\n                    }\n                    else {\n                        task.runCount = 0;\n                        this._updateTaskCount(task, -1);\n                        reEntryGuard &&\n                            task._transitionTo(notScheduled, running, notScheduled);\n                    }\n                }\n                _currentZoneFrame = _currentZoneFrame.parent;\n                _currentTask = previousTask;\n            }\n        };\n        Zone.prototype.scheduleTask = function (task) {\n            if (task.zone && task.zone !== this) {\n                // check if the task was rescheduled, the newZone\n                // should not be the children of the original zone\n                var newZone = this;\n                while (newZone) {\n                    if (newZone === task.zone) {\n                        throw Error(\"can not reschedule task to \" + this\n                            .name + \" which is descendants of the original zone \" + task.zone.name);\n                    }\n                    newZone = newZone.parent;\n                }\n            }\n            task._transitionTo(scheduling, notScheduled);\n            var zoneDelegates = [];\n            task._zoneDelegates = zoneDelegates;\n            task._zone = this;\n            try {\n                task = this._zoneDelegate.scheduleTask(this, task);\n            }\n            catch (err) {\n                // should set task's state to unknown when scheduleTask throw error\n                // because the err may from reschedule, so the fromState maybe notScheduled\n                task._transitionTo(unknown, scheduling, notScheduled);\n                // TODO: @JiaLiPassion, should we check the result from handleError?\n                this._zoneDelegate.handleError(this, err);\n                throw err;\n            }\n            if (task._zoneDelegates === zoneDelegates) {\n                // we have to check because internally the delegate can reschedule the task.\n                this._updateTaskCount(task, 1);\n            }\n            if (task.state == scheduling) {\n                task._transitionTo(scheduled, scheduling);\n            }\n            return task;\n        };\n        Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {\n            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, null));\n        };\n        Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {\n            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\n        };\n        Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {\n            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\n        };\n        Zone.prototype.cancelTask = function (task) {\n            if (task.zone != this)\n                throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' +\n                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n            task._transitionTo(canceling, scheduled, running);\n            try {\n                this._zoneDelegate.cancelTask(this, task);\n            }\n            catch (err) {\n                // if error occurs when cancelTask, transit the state to unknown\n                task._transitionTo(unknown, canceling);\n                this._zoneDelegate.handleError(this, err);\n                throw err;\n            }\n            this._updateTaskCount(task, -1);\n            task._transitionTo(notScheduled, canceling);\n            task.runCount = 0;\n            return task;\n        };\n        Zone.prototype._updateTaskCount = function (task, count) {\n            var zoneDelegates = task._zoneDelegates;\n            if (count == -1) {\n                task._zoneDelegates = null;\n            }\n            for (var i = 0; i < zoneDelegates.length; i++) {\n                zoneDelegates[i]._updateTaskCount(task.type, count);\n            }\n        };\n        return Zone;\n    }());\n    Zone.__symbol__ = __symbol__;\n    var DELEGATE_ZS = {\n        name: '',\n        onHasTask: function (delegate, _, target, hasTaskState) {\n            return delegate.hasTask(target, hasTaskState);\n        },\n        onScheduleTask: function (delegate, _, target, task) {\n            return delegate.scheduleTask(target, task);\n        },\n        onInvokeTask: function (delegate, _, target, task, applyThis, applyArgs) { return delegate.invokeTask(target, task, applyThis, applyArgs); },\n        onCancelTask: function (delegate, _, target, task) {\n            return delegate.cancelTask(target, task);\n        }\n    };\n    var ZoneDelegate = (function () {\n        function ZoneDelegate(zone, parentDelegate, zoneSpec) {\n            this._taskCounts = { 'microTask': 0, 'macroTask': 0, 'eventTask': 0 };\n            this.zone = zone;\n            this._parentDelegate = parentDelegate;\n            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n            this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate.zone);\n            this._interceptZS =\n                zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n            this._interceptDlgt =\n                zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n            this._interceptCurrZone =\n                zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);\n            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n            this._invokeDlgt =\n                zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n            this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);\n            this._handleErrorZS =\n                zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n            this._handleErrorDlgt =\n                zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n            this._handleErrorCurrZone =\n                zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);\n            this._scheduleTaskZS =\n                zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n            this._scheduleTaskDlgt =\n                zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n            this._scheduleTaskCurrZone =\n                zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);\n            this._invokeTaskZS =\n                zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n            this._invokeTaskDlgt =\n                zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n            this._invokeTaskCurrZone =\n                zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);\n            this._cancelTaskZS =\n                zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n            this._cancelTaskDlgt =\n                zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n            this._cancelTaskCurrZone =\n                zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);\n            this._hasTaskZS = null;\n            this._hasTaskDlgt = null;\n            this._hasTaskDlgtOwner = null;\n            this._hasTaskCurrZone = null;\n            var zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\n            var parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\n            if (zoneSpecHasTask || parentHasTask) {\n                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such\n                // a case all task related interceptors must go through this ZD. We can't short circuit it.\n                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\n                this._hasTaskDlgt = parentDelegate;\n                this._hasTaskDlgtOwner = this;\n                this._hasTaskCurrZone = zone;\n                if (!zoneSpec.onScheduleTask) {\n                    this._scheduleTaskZS = DELEGATE_ZS;\n                    this._scheduleTaskDlgt = parentDelegate;\n                    this._scheduleTaskCurrZone = this.zone;\n                }\n                if (!zoneSpec.onInvokeTask) {\n                    this._invokeTaskZS = DELEGATE_ZS;\n                    this._invokeTaskDlgt = parentDelegate;\n                    this._invokeTaskCurrZone = this.zone;\n                }\n                if (!zoneSpec.onCancelTask) {\n                    this._cancelTaskZS = DELEGATE_ZS;\n                    this._cancelTaskDlgt = parentDelegate;\n                    this._cancelTaskCurrZone = this.zone;\n                }\n            }\n        }\n        ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {\n            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :\n                new Zone(targetZone, zoneSpec);\n        };\n        ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {\n            return this._interceptZS ?\n                this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) :\n                callback;\n        };\n        ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {\n            return this._invokeZS ?\n                this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) :\n                callback.apply(applyThis, applyArgs);\n        };\n        ZoneDelegate.prototype.handleError = function (targetZone, error) {\n            return this._handleErrorZS ?\n                this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) :\n                true;\n        };\n        ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {\n            var returnTask = task;\n            if (this._scheduleTaskZS) {\n                if (this._hasTaskZS) {\n                    returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\n                }\n                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);\n                if (!returnTask)\n                    returnTask = task;\n            }\n            else {\n                if (task.scheduleFn) {\n                    task.scheduleFn(task);\n                }\n                else if (task.type == microTask) {\n                    scheduleMicroTask(task);\n                }\n                else {\n                    throw new Error('Task is missing scheduleFn.');\n                }\n            }\n            return returnTask;\n        };\n        ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {\n            return this._invokeTaskZS ?\n                this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) :\n                task.callback.apply(applyThis, applyArgs);\n        };\n        ZoneDelegate.prototype.cancelTask = function (targetZone, task) {\n            var value;\n            if (this._cancelTaskZS) {\n                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\n            }\n            else {\n                if (!task.cancelFn) {\n                    throw Error('Task is not cancelable');\n                }\n                value = task.cancelFn(task);\n            }\n            return value;\n        };\n        ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {\n            // hasTask should not throw error so other ZoneDelegate\n            // can still trigger hasTask callback\n            try {\n                return this._hasTaskZS &&\n                    this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\n            }\n            catch (err) {\n                this.handleError(targetZone, err);\n            }\n        };\n        ZoneDelegate.prototype._updateTaskCount = function (type, count) {\n            var counts = this._taskCounts;\n            var prev = counts[type];\n            var next = counts[type] = prev + count;\n            if (next < 0) {\n                throw new Error('More tasks executed then were scheduled.');\n            }\n            if (prev == 0 || next == 0) {\n                var isEmpty = {\n                    microTask: counts.microTask > 0,\n                    macroTask: counts.macroTask > 0,\n                    eventTask: counts.eventTask > 0,\n                    change: type\n                };\n                this.hasTask(this.zone, isEmpty);\n            }\n        };\n        return ZoneDelegate;\n    }());\n    var ZoneTask = (function () {\n        function ZoneTask(type, source, callback, options, scheduleFn, cancelFn) {\n            this._zone = null;\n            this.runCount = 0;\n            this._zoneDelegates = null;\n            this._state = 'notScheduled';\n            this.type = type;\n            this.source = source;\n            this.data = options;\n            this.scheduleFn = scheduleFn;\n            this.cancelFn = cancelFn;\n            this.callback = callback;\n            var self = this;\n            this.invoke = function () {\n                _numberOfNestedTaskFrames++;\n                try {\n                    self.runCount++;\n                    return self.zone.runTask(self, this, arguments);\n                }\n                finally {\n                    if (_numberOfNestedTaskFrames == 1) {\n                        drainMicroTaskQueue();\n                    }\n                    _numberOfNestedTaskFrames--;\n                }\n            };\n        }\n        Object.defineProperty(ZoneTask.prototype, \"zone\", {\n            get: function () {\n                return this._zone;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ZoneTask.prototype, \"state\", {\n            get: function () {\n                return this._state;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ZoneTask.prototype.cancelScheduleRequest = function () {\n            this._transitionTo(notScheduled, scheduling);\n        };\n        ZoneTask.prototype._transitionTo = function (toState, fromState1, fromState2) {\n            if (this._state === fromState1 || this._state === fromState2) {\n                this._state = toState;\n                if (toState == notScheduled) {\n                    this._zoneDelegates = null;\n                }\n            }\n            else {\n                throw new Error(this.type + \" '\" + this.source + \"': can not transition to '\" + toState + \"', expecting state '\" + fromState1 + \"'\" + (fromState2 ?\n                    ' or \\'' + fromState2 + '\\'' :\n                    '') + \", was '\" + this._state + \"'.\");\n            }\n        };\n        ZoneTask.prototype.toString = function () {\n            if (this.data && typeof this.data.handleId !== 'undefined') {\n                return this.data.handleId;\n            }\n            else {\n                return Object.prototype.toString.call(this);\n            }\n        };\n        // add toJSON method to prevent cyclic error when\n        // call JSON.stringify(zoneTask)\n        ZoneTask.prototype.toJSON = function () {\n            return {\n                type: this.type,\n                state: this.state,\n                source: this.source,\n                zone: this.zone.name,\n                invoke: this.invoke,\n                scheduleFn: this.scheduleFn,\n                cancelFn: this.cancelFn,\n                runCount: this.runCount,\n                callback: this.callback\n            };\n        };\n        return ZoneTask;\n    }());\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    ///  MICROTASK QUEUE\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    var symbolSetTimeout = __symbol__('setTimeout');\n    var symbolPromise = __symbol__('Promise');\n    var symbolThen = __symbol__('then');\n    var _microTaskQueue = [];\n    var _isDrainingMicrotaskQueue = false;\n    function scheduleMicroTask(task) {\n        // if we are not running in any task, and there has not been anything scheduled\n        // we must bootstrap the initial task creation by manually scheduling the drain\n        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\n            // We are not running in Task, so we need to kickstart the microtask queue.\n            if (global[symbolPromise]) {\n                global[symbolPromise].resolve(0)[symbolThen](drainMicroTaskQueue);\n            }\n            else {\n                global[symbolSetTimeout](drainMicroTaskQueue, 0);\n            }\n        }\n        task && _microTaskQueue.push(task);\n    }\n    function drainMicroTaskQueue() {\n        if (!_isDrainingMicrotaskQueue) {\n            _isDrainingMicrotaskQueue = true;\n            while (_microTaskQueue.length) {\n                var queue = _microTaskQueue;\n                _microTaskQueue = [];\n                for (var i = 0; i < queue.length; i++) {\n                    var task = queue[i];\n                    try {\n                        task.zone.runTask(task, null, null);\n                    }\n                    catch (error) {\n                        _api.onUnhandledError(error);\n                    }\n                }\n            }\n            var showError = !Zone[__symbol__('ignoreConsoleErrorUncaughtError')];\n            _api.microtaskDrainDone();\n            _isDrainingMicrotaskQueue = false;\n        }\n    }\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    ///  BOOTSTRAP\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    var NO_ZONE = { name: 'NO ZONE' };\n    var notScheduled = 'notScheduled', scheduling = 'scheduling', scheduled = 'scheduled', running = 'running', canceling = 'canceling', unknown = 'unknown';\n    var microTask = 'microTask', macroTask = 'macroTask', eventTask = 'eventTask';\n    var patches = {};\n    var _api = {\n        symbol: __symbol__,\n        currentZoneFrame: function () { return _currentZoneFrame; },\n        onUnhandledError: noop,\n        microtaskDrainDone: noop,\n        scheduleMicroTask: scheduleMicroTask,\n        showUncaughtError: function () { return !Zone[__symbol__('ignoreConsoleErrorUncaughtError')]; },\n        patchEventTargetMethods: function () { return false; },\n        patchOnProperties: noop\n    };\n    var _currentZoneFrame = { parent: null, zone: new Zone(null, null) };\n    var _currentTask = null;\n    var _numberOfNestedTaskFrames = 0;\n    function noop() { }\n    function __symbol__(name) {\n        return '__zone_symbol__' + name;\n    }\n    performanceMeasure('Zone', 'Zone');\n    return global['Zone'] = Zone;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('ZoneAwarePromise', function (global, Zone, api) {\n    var __symbol__ = api.symbol;\n    var _uncaughtPromiseErrors = [];\n    var symbolPromise = __symbol__('Promise');\n    var symbolThen = __symbol__('then');\n    api.onUnhandledError = function (e) {\n        if (api.showUncaughtError()) {\n            var rejection = e && e.rejection;\n            if (rejection) {\n                console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);\n            }\n            console.error(e);\n        }\n    };\n    api.microtaskDrainDone = function () {\n        while (_uncaughtPromiseErrors.length) {\n            var _loop_1 = function () {\n                var uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n                try {\n                    uncaughtPromiseError.zone.runGuarded(function () {\n                        throw uncaughtPromiseError;\n                    });\n                }\n                catch (error) {\n                    handleUnhandledRejection(error);\n                }\n            };\n            while (_uncaughtPromiseErrors.length) {\n                _loop_1();\n            }\n        }\n    };\n    function handleUnhandledRejection(e) {\n        api.onUnhandledError(e);\n        try {\n            var handler = Zone[__symbol__('unhandledPromiseRejectionHandler')];\n            if (handler && typeof handler === 'function') {\n                handler.apply(this, [e]);\n            }\n        }\n        catch (err) {\n        }\n    }\n    function isThenable(value) {\n        return value && value.then;\n    }\n    function forwardResolution(value) {\n        return value;\n    }\n    function forwardRejection(rejection) {\n        return ZoneAwarePromise.reject(rejection);\n    }\n    var symbolState = __symbol__('state');\n    var symbolValue = __symbol__('value');\n    var source = 'Promise.then';\n    var UNRESOLVED = null;\n    var RESOLVED = true;\n    var REJECTED = false;\n    var REJECTED_NO_CATCH = 0;\n    function makeResolver(promise, state) {\n        return function (v) {\n            try {\n                resolvePromise(promise, state, v);\n            }\n            catch (err) {\n                resolvePromise(promise, false, err);\n            }\n            // Do not return value or you will break the Promise spec.\n        };\n    }\n    var once = function () {\n        var wasCalled = false;\n        return function wrapper(wrappedFunction) {\n            return function () {\n                if (wasCalled) {\n                    return;\n                }\n                wasCalled = true;\n                wrappedFunction.apply(null, arguments);\n            };\n        };\n    };\n    // Promise Resolution\n    function resolvePromise(promise, state, value) {\n        var onceWrapper = once();\n        if (promise === value) {\n            throw new TypeError('Promise resolved with itself');\n        }\n        if (promise[symbolState] === UNRESOLVED) {\n            // should only get value.then once based on promise spec.\n            var then = null;\n            try {\n                if (typeof value === 'object' || typeof value === 'function') {\n                    then = value && value.then;\n                }\n            }\n            catch (err) {\n                onceWrapper(function () {\n                    resolvePromise(promise, false, err);\n                })();\n                return promise;\n            }\n            // if (value instanceof ZoneAwarePromise) {\n            if (state !== REJECTED && value instanceof ZoneAwarePromise &&\n                value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) &&\n                value[symbolState] !== UNRESOLVED) {\n                clearRejectedNoCatch(value);\n                resolvePromise(promise, value[symbolState], value[symbolValue]);\n            }\n            else if (state !== REJECTED && typeof then === 'function') {\n                try {\n                    then.apply(value, [\n                        onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false))\n                    ]);\n                }\n                catch (err) {\n                    onceWrapper(function () {\n                        resolvePromise(promise, false, err);\n                    })();\n                }\n            }\n            else {\n                promise[symbolState] = state;\n                var queue = promise[symbolValue];\n                promise[symbolValue] = value;\n                // record task information in value when error occurs, so we can\n                // do some additional work such as render longStackTrace\n                if (state === REJECTED && value instanceof Error) {\n                    value[__symbol__('currentTask')] = Zone.currentTask;\n                }\n                for (var i = 0; i < queue.length;) {\n                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n                }\n                if (queue.length == 0 && state == REJECTED) {\n                    promise[symbolState] = REJECTED_NO_CATCH;\n                    try {\n                        throw new Error('Uncaught (in promise): ' + value +\n                            (value && value.stack ? '\\n' + value.stack : ''));\n                    }\n                    catch (err) {\n                        var error_1 = err;\n                        error_1.rejection = value;\n                        error_1.promise = promise;\n                        error_1.zone = Zone.current;\n                        error_1.task = Zone.currentTask;\n                        _uncaughtPromiseErrors.push(error_1);\n                        api.scheduleMicroTask(); // to make sure that it is running\n                    }\n                }\n            }\n        }\n        // Resolving an already resolved promise is a noop.\n        return promise;\n    }\n    function clearRejectedNoCatch(promise) {\n        if (promise[symbolState] === REJECTED_NO_CATCH) {\n            // if the promise is rejected no catch status\n            // and queue.length > 0, means there is a error handler\n            // here to handle the rejected promise, we should trigger\n            // windows.rejectionhandled eventHandler or nodejs rejectionHandled\n            // eventHandler\n            try {\n                var handler = Zone[__symbol__('rejectionHandledHandler')];\n                if (handler && typeof handler === 'function') {\n                    handler.apply(this, [{ rejection: promise[symbolValue], promise: promise }]);\n                }\n            }\n            catch (err) {\n            }\n            promise[symbolState] = REJECTED;\n            for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {\n                if (promise === _uncaughtPromiseErrors[i].promise) {\n                    _uncaughtPromiseErrors.splice(i, 1);\n                }\n            }\n        }\n    }\n    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n        clearRejectedNoCatch(promise);\n        var delegate = promise[symbolState] ?\n            (typeof onFulfilled === 'function') ? onFulfilled : forwardResolution :\n            (typeof onRejected === 'function') ? onRejected : forwardRejection;\n        zone.scheduleMicroTask(source, function () {\n            try {\n                resolvePromise(chainPromise, true, zone.run(delegate, undefined, [promise[symbolValue]]));\n            }\n            catch (error) {\n                resolvePromise(chainPromise, false, error);\n            }\n        });\n    }\n    var ZoneAwarePromise = (function () {\n        function ZoneAwarePromise(executor) {\n            var promise = this;\n            if (!(promise instanceof ZoneAwarePromise)) {\n                throw new Error('Must be an instanceof Promise.');\n            }\n            promise[symbolState] = UNRESOLVED;\n            promise[symbolValue] = []; // queue;\n            try {\n                executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));\n            }\n            catch (error) {\n                resolvePromise(promise, false, error);\n            }\n        }\n        ZoneAwarePromise.toString = function () {\n            return 'function ZoneAwarePromise() { [native code] }';\n        };\n        ZoneAwarePromise.resolve = function (value) {\n            return resolvePromise(new this(null), RESOLVED, value);\n        };\n        ZoneAwarePromise.reject = function (error) {\n            return resolvePromise(new this(null), REJECTED, error);\n        };\n        ZoneAwarePromise.race = function (values) {\n            var resolve;\n            var reject;\n            var promise = new this(function (res, rej) {\n                _a = [res, rej], resolve = _a[0], reject = _a[1];\n                var _a;\n            });\n            function onResolve(value) {\n                promise && (promise = null || resolve(value));\n            }\n            function onReject(error) {\n                promise && (promise = null || reject(error));\n            }\n            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n                var value = values_1[_i];\n                if (!isThenable(value)) {\n                    value = this.resolve(value);\n                }\n                value.then(onResolve, onReject);\n            }\n            return promise;\n        };\n        ZoneAwarePromise.all = function (values) {\n            var resolve;\n            var reject;\n            var promise = new this(function (res, rej) {\n                resolve = res;\n                reject = rej;\n            });\n            var count = 0;\n            var resolvedValues = [];\n            for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {\n                var value = values_2[_i];\n                if (!isThenable(value)) {\n                    value = this.resolve(value);\n                }\n                value.then((function (index) { return function (value) {\n                    resolvedValues[index] = value;\n                    count--;\n                    if (!count) {\n                        resolve(resolvedValues);\n                    }\n                }; })(count), reject);\n                count++;\n            }\n            if (!count)\n                resolve(resolvedValues);\n            return promise;\n        };\n        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {\n            var chainPromise = new this.constructor(null);\n            var zone = Zone.current;\n            if (this[symbolState] == UNRESOLVED) {\n                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n            }\n            else {\n                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n            }\n            return chainPromise;\n        };\n        ZoneAwarePromise.prototype.catch = function (onRejected) {\n            return this.then(null, onRejected);\n        };\n        return ZoneAwarePromise;\n    }());\n    // Protect against aggressive optimizers dropping seemingly unused properties.\n    // E.g. Closure Compiler in advanced mode.\n    ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;\n    ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;\n    ZoneAwarePromise['race'] = ZoneAwarePromise.race;\n    ZoneAwarePromise['all'] = ZoneAwarePromise.all;\n    var NativePromise = global[symbolPromise] = global['Promise'];\n    global['Promise'] = ZoneAwarePromise;\n    var symbolThenPatched = __symbol__('thenPatched');\n    function patchThen(Ctor) {\n        var proto = Ctor.prototype;\n        var originalThen = proto.then;\n        // Keep a reference to the original method.\n        proto[symbolThen] = originalThen;\n        Ctor.prototype.then = function (onResolve, onReject) {\n            var _this = this;\n            var wrapped = new ZoneAwarePromise(function (resolve, reject) {\n                originalThen.call(_this, resolve, reject);\n            });\n            return wrapped.then(onResolve, onReject);\n        };\n        Ctor[symbolThenPatched] = true;\n    }\n    function zoneify(fn) {\n        return function () {\n            var resultPromise = fn.apply(this, arguments);\n            if (resultPromise instanceof ZoneAwarePromise) {\n                return resultPromise;\n            }\n            var ctor = resultPromise.constructor;\n            if (!ctor[symbolThenPatched]) {\n                patchThen(ctor);\n            }\n            return resultPromise;\n        };\n    }\n    if (NativePromise) {\n        patchThen(NativePromise);\n        var fetch_1 = global['fetch'];\n        if (typeof fetch_1 == 'function') {\n            global['fetch'] = zoneify(fetch_1);\n        }\n    }\n    // This is not part of public API, but it is useful for tests, so we expose it.\n    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;\n    return ZoneAwarePromise;\n});\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Suppress closure compiler errors about unknown 'Zone' variable\n * @fileoverview\n * @suppress {undefinedVars,globalThis}\n */\nvar zoneSymbol = function (n) { return \"__zone_symbol__\" + n; };\nvar _global = typeof window === 'object' && window || typeof self === 'object' && self || global;\nfunction bindArguments(args, source) {\n    for (var i = args.length - 1; i >= 0; i--) {\n        if (typeof args[i] === 'function') {\n            args[i] = Zone.current.wrap(args[i], source + '_' + i);\n        }\n    }\n    return args;\n}\nfunction patchPrototype(prototype, fnNames) {\n    var source = prototype.constructor['name'];\n    var _loop_1 = function (i) {\n        var name_1 = fnNames[i];\n        var delegate = prototype[name_1];\n        if (delegate) {\n            prototype[name_1] = (function (delegate) {\n                var patched = function () {\n                    return delegate.apply(this, bindArguments(arguments, source + '.' + name_1));\n                };\n                attachOriginToPatched(patched, delegate);\n                return patched;\n            })(delegate);\n        }\n    };\n    for (var i = 0; i < fnNames.length; i++) {\n        _loop_1(i);\n    }\n}\nvar isWebWorker = (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope);\n// Make sure to access `process` through `_global` so that WebPack does not accidently browserify\n// this code.\nvar isNode = (!('nw' in _global) && typeof _global.process !== 'undefined' &&\n    {}.toString.call(_global.process) === '[object process]');\nvar isBrowser = !isNode && !isWebWorker && !!(typeof window !== 'undefined' && window['HTMLElement']);\n// we are in electron of nw, so we are both browser and nodejs\n// Make sure to access `process` through `_global` so that WebPack does not accidently browserify\n// this code.\nvar isMix = typeof _global.process !== 'undefined' &&\n    {}.toString.call(_global.process) === '[object process]' && !isWebWorker &&\n    !!(typeof window !== 'undefined' && window['HTMLElement']);\nfunction patchProperty(obj, prop, prototype) {\n    var desc = Object.getOwnPropertyDescriptor(obj, prop);\n    if (!desc && prototype) {\n        // when patch window object, use prototype to check prop exist or not\n        var prototypeDesc = Object.getOwnPropertyDescriptor(prototype, prop);\n        if (prototypeDesc) {\n            desc = { enumerable: true, configurable: true };\n        }\n    }\n    // if the descriptor not exists or is not configurable\n    // just return\n    if (!desc || !desc.configurable) {\n        return;\n    }\n    // A property descriptor cannot have getter/setter and be writable\n    // deleting the writable and value properties avoids this error:\n    //\n    // TypeError: property descriptors must not specify a value or be writable when a\n    // getter or setter has been specified\n    delete desc.writable;\n    delete desc.value;\n    var originalDescGet = desc.get;\n    // substr(2) cuz 'onclick' -> 'click', etc\n    var eventName = prop.substr(2);\n    var _prop = zoneSymbol('_' + prop);\n    desc.set = function (newValue) {\n        // in some of windows's onproperty callback, this is undefined\n        // so we need to check it\n        var target = this;\n        if (!target && obj === _global) {\n            target = _global;\n        }\n        if (!target) {\n            return;\n        }\n        var previousValue = target[_prop];\n        if (previousValue) {\n            target.removeEventListener(eventName, previousValue);\n        }\n        if (typeof newValue === 'function') {\n            var wrapFn = function (event) {\n                var result = newValue.apply(this, arguments);\n                if (result != undefined && !result) {\n                    event.preventDefault();\n                }\n                return result;\n            };\n            target[_prop] = wrapFn;\n            target.addEventListener(eventName, wrapFn, false);\n        }\n        else {\n            target[_prop] = null;\n        }\n    };\n    // The getter would return undefined for unassigned properties but the default value of an\n    // unassigned property is null\n    desc.get = function () {\n        // in some of windows's onproperty callback, this is undefined\n        // so we need to check it\n        var target = this;\n        if (!target && obj === _global) {\n            target = _global;\n        }\n        if (!target) {\n            return null;\n        }\n        if (target.hasOwnProperty(_prop)) {\n            return target[_prop];\n        }\n        else if (originalDescGet) {\n            // result will be null when use inline event attribute,\n            // such as <button onclick=\"func();\">OK</button>\n            // because the onclick function is internal raw uncompiled handler\n            // the onclick will be evaluated when first time event was triggered or\n            // the property is accessed, https://github.com/angular/zone.js/issues/525\n            // so we should use original native get to retrieve the handler\n            var value = originalDescGet && originalDescGet.apply(this);\n            if (value) {\n                desc.set.apply(this, [value]);\n                if (typeof target['removeAttribute'] === 'function') {\n                    target.removeAttribute(prop);\n                }\n                return value;\n            }\n        }\n        return null;\n    };\n    Object.defineProperty(obj, prop, desc);\n}\nfunction patchOnProperties(obj, properties, prototype) {\n    if (properties) {\n        for (var i = 0; i < properties.length; i++) {\n            patchProperty(obj, 'on' + properties[i], prototype);\n        }\n    }\n    else {\n        var onProperties = [];\n        for (var prop in obj) {\n            if (prop.substr(0, 2) == 'on') {\n                onProperties.push(prop);\n            }\n        }\n        for (var j = 0; j < onProperties.length; j++) {\n            patchProperty(obj, onProperties[j], prototype);\n        }\n    }\n}\nvar EVENT_TASKS = zoneSymbol('eventTasks');\n// For EventTarget\nvar ADD_EVENT_LISTENER = 'addEventListener';\nvar REMOVE_EVENT_LISTENER = 'removeEventListener';\n// compare the EventListenerOptionsOrCapture\n// 1. if the options is usCapture: boolean, compare the useCpature values directly\n// 2. if the options is EventListerOptions, only compare the capture\nfunction compareEventListenerOptions(left, right) {\n    var leftCapture = (typeof left === 'boolean') ?\n        left :\n        ((typeof left === 'object') ? (left && left.capture) : false);\n    var rightCapture = (typeof right === 'boolean') ?\n        right :\n        ((typeof right === 'object') ? (right && right.capture) : false);\n    return !!leftCapture === !!rightCapture;\n}\nfunction findExistingRegisteredTask(target, handler, name, options, remove) {\n    var eventTasks = target[EVENT_TASKS];\n    if (eventTasks) {\n        for (var i = 0; i < eventTasks.length; i++) {\n            var eventTask = eventTasks[i];\n            var data = eventTask.data;\n            var listener = data.handler;\n            if ((data.handler === handler || listener.listener === handler) &&\n                compareEventListenerOptions(data.options, options) && data.eventName === name) {\n                if (remove) {\n                    eventTasks.splice(i, 1);\n                }\n                return eventTask;\n            }\n        }\n    }\n    return null;\n}\nfunction attachRegisteredEvent(target, eventTask, isPrepend) {\n    var eventTasks = target[EVENT_TASKS];\n    if (!eventTasks) {\n        eventTasks = target[EVENT_TASKS] = [];\n    }\n    if (isPrepend) {\n        eventTasks.unshift(eventTask);\n    }\n    else {\n        eventTasks.push(eventTask);\n    }\n}\nvar defaultListenerMetaCreator = function (self, args) {\n    return {\n        options: args[2],\n        eventName: args[0],\n        handler: args[1],\n        target: self || _global,\n        name: args[0],\n        crossContext: false,\n        invokeAddFunc: function (addFnSymbol, delegate) {\n            // check if the data is cross site context, if it is, fallback to\n            // remove the delegate directly and try catch error\n            if (!this.crossContext) {\n                if (delegate && delegate.invoke) {\n                    return this.target[addFnSymbol](this.eventName, delegate.invoke, this.options);\n                }\n                else {\n                    return this.target[addFnSymbol](this.eventName, delegate, this.options);\n                }\n            }\n            else {\n                // add a if/else branch here for performance concern, for most times\n                // cross site context is false, so we don't need to try/catch\n                try {\n                    return this.target[addFnSymbol](this.eventName, delegate, this.options);\n                }\n                catch (err) {\n                    // do nothing here is fine, because objects in a cross-site context are unusable\n                }\n            }\n        },\n        invokeRemoveFunc: function (removeFnSymbol, delegate) {\n            // check if the data is cross site context, if it is, fallback to\n            // remove the delegate directly and try catch error\n            if (!this.crossContext) {\n                if (delegate && delegate.invoke) {\n                    return this.target[removeFnSymbol](this.eventName, delegate.invoke, this.options);\n                }\n                else {\n                    return this.target[removeFnSymbol](this.eventName, delegate, this.options);\n                }\n            }\n            else {\n                // add a if/else branch here for performance concern, for most times\n                // cross site context is false, so we don't need to try/catch\n                try {\n                    return this.target[removeFnSymbol](this.eventName, delegate, this.options);\n                }\n                catch (err) {\n                    // do nothing here is fine, because objects in a cross-site context are unusable\n                }\n            }\n        }\n    };\n};\nfunction makeZoneAwareAddListener(addFnName, removeFnName, useCapturingParam, allowDuplicates, isPrepend, metaCreator) {\n    if (useCapturingParam === void 0) { useCapturingParam = true; }\n    if (allowDuplicates === void 0) { allowDuplicates = false; }\n    if (isPrepend === void 0) { isPrepend = false; }\n    if (metaCreator === void 0) { metaCreator = defaultListenerMetaCreator; }\n    var addFnSymbol = zoneSymbol(addFnName);\n    var removeFnSymbol = zoneSymbol(removeFnName);\n    var defaultUseCapturing = useCapturingParam ? false : undefined;\n    function scheduleEventListener(eventTask) {\n        var meta = eventTask.data;\n        attachRegisteredEvent(meta.target, eventTask, isPrepend);\n        return meta.invokeAddFunc(addFnSymbol, eventTask);\n    }\n    function cancelEventListener(eventTask) {\n        var meta = eventTask.data;\n        findExistingRegisteredTask(meta.target, eventTask.invoke, meta.eventName, meta.options, true);\n        return meta.invokeRemoveFunc(removeFnSymbol, eventTask);\n    }\n    return function zoneAwareAddListener(self, args) {\n        var data = metaCreator(self, args);\n        data.options = data.options || defaultUseCapturing;\n        // - Inside a Web Worker, `this` is undefined, the context is `global`\n        // - When `addEventListener` is called on the global context in strict mode, `this` is undefined\n        // see https://github.com/angular/zone.js/issues/190\n        var delegate = null;\n        if (typeof data.handler == 'function') {\n            delegate = data.handler;\n        }\n        else if (data.handler && data.handler.handleEvent) {\n            delegate = function (event) { return data.handler.handleEvent(event); };\n        }\n        var validZoneHandler = false;\n        try {\n            // In cross site contexts (such as WebDriver frameworks like Selenium),\n            // accessing the handler object here will cause an exception to be thrown which\n            // will fail tests prematurely.\n            validZoneHandler = data.handler && data.handler.toString() === '[object FunctionWrapper]';\n        }\n        catch (error) {\n            // we can still try to add the data.handler even we are in cross site context\n            data.crossContext = true;\n            return data.invokeAddFunc(addFnSymbol, data.handler);\n        }\n        // Ignore special listeners of IE11 & Edge dev tools, see\n        // https://github.com/angular/zone.js/issues/150\n        if (!delegate || validZoneHandler) {\n            return data.invokeAddFunc(addFnSymbol, data.handler);\n        }\n        if (!allowDuplicates) {\n            var eventTask = findExistingRegisteredTask(data.target, data.handler, data.eventName, data.options, false);\n            if (eventTask) {\n                // we already registered, so this will have noop.\n                return data.invokeAddFunc(addFnSymbol, eventTask);\n            }\n        }\n        var zone = Zone.current;\n        var source = data.target.constructor['name'] + '.' + addFnName + ':' + data.eventName;\n        zone.scheduleEventTask(source, delegate, data, scheduleEventListener, cancelEventListener);\n    };\n}\nfunction makeZoneAwareRemoveListener(fnName, useCapturingParam, metaCreator) {\n    if (useCapturingParam === void 0) { useCapturingParam = true; }\n    if (metaCreator === void 0) { metaCreator = defaultListenerMetaCreator; }\n    var symbol = zoneSymbol(fnName);\n    var defaultUseCapturing = useCapturingParam ? false : undefined;\n    return function zoneAwareRemoveListener(self, args) {\n        var data = metaCreator(self, args);\n        data.options = data.options || defaultUseCapturing;\n        // - Inside a Web Worker, `this` is undefined, the context is `global`\n        // - When `addEventListener` is called on the global context in strict mode, `this` is undefined\n        // see https://github.com/angular/zone.js/issues/190\n        var delegate = null;\n        if (typeof data.handler == 'function') {\n            delegate = data.handler;\n        }\n        else if (data.handler && data.handler.handleEvent) {\n            delegate = function (event) { return data.handler.handleEvent(event); };\n        }\n        var validZoneHandler = false;\n        try {\n            // In cross site contexts (such as WebDriver frameworks like Selenium),\n            // accessing the handler object here will cause an exception to be thrown which\n            // will fail tests prematurely.\n            validZoneHandler = data.handler && data.handler.toString() === '[object FunctionWrapper]';\n        }\n        catch (error) {\n            data.crossContext = true;\n            return data.invokeRemoveFunc(symbol, data.handler);\n        }\n        // Ignore special listeners of IE11 & Edge dev tools, see\n        // https://github.com/angular/zone.js/issues/150\n        if (!delegate || validZoneHandler) {\n            return data.invokeRemoveFunc(symbol, data.handler);\n        }\n        var eventTask = findExistingRegisteredTask(data.target, data.handler, data.eventName, data.options, true);\n        if (eventTask) {\n            eventTask.zone.cancelTask(eventTask);\n        }\n        else {\n            data.invokeRemoveFunc(symbol, data.handler);\n        }\n    };\n}\n\n\nfunction patchEventTargetMethods(obj, addFnName, removeFnName, metaCreator) {\n    if (addFnName === void 0) { addFnName = ADD_EVENT_LISTENER; }\n    if (removeFnName === void 0) { removeFnName = REMOVE_EVENT_LISTENER; }\n    if (metaCreator === void 0) { metaCreator = defaultListenerMetaCreator; }\n    if (obj && obj[addFnName]) {\n        patchMethod(obj, addFnName, function () { return makeZoneAwareAddListener(addFnName, removeFnName, true, false, false, metaCreator); });\n        patchMethod(obj, removeFnName, function () { return makeZoneAwareRemoveListener(removeFnName, true, metaCreator); });\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nvar originalInstanceKey = zoneSymbol('originalInstance');\n// wrap some native API on `window`\nfunction patchClass(className) {\n    var OriginalClass = _global[className];\n    if (!OriginalClass)\n        return;\n    // keep original class in global\n    _global[zoneSymbol(className)] = OriginalClass;\n    _global[className] = function () {\n        var a = bindArguments(arguments, className);\n        switch (a.length) {\n            case 0:\n                this[originalInstanceKey] = new OriginalClass();\n                break;\n            case 1:\n                this[originalInstanceKey] = new OriginalClass(a[0]);\n                break;\n            case 2:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\n                break;\n            case 3:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\n                break;\n            case 4:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\n                break;\n            default:\n                throw new Error('Arg list too long.');\n        }\n    };\n    // attach original delegate to patched function\n    attachOriginToPatched(_global[className], OriginalClass);\n    var instance = new OriginalClass(function () { });\n    var prop;\n    for (prop in instance) {\n        // https://bugs.webkit.org/show_bug.cgi?id=44721\n        if (className === 'XMLHttpRequest' && prop === 'responseBlob')\n            continue;\n        (function (prop) {\n            if (typeof instance[prop] === 'function') {\n                _global[className].prototype[prop] = function () {\n                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\n                };\n            }\n            else {\n                Object.defineProperty(_global[className].prototype, prop, {\n                    set: function (fn) {\n                        if (typeof fn === 'function') {\n                            this[originalInstanceKey][prop] = Zone.current.wrap(fn, className + '.' + prop);\n                            // keep callback in wrapped function so we can\n                            // use it in Function.prototype.toString to return\n                            // the native one.\n                            attachOriginToPatched(this[originalInstanceKey][prop], fn);\n                        }\n                        else {\n                            this[originalInstanceKey][prop] = fn;\n                        }\n                    },\n                    get: function () {\n                        return this[originalInstanceKey][prop];\n                    }\n                });\n            }\n        }(prop));\n    }\n    for (prop in OriginalClass) {\n        if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {\n            _global[className][prop] = OriginalClass[prop];\n        }\n    }\n}\nfunction patchMethod(target, name, patchFn) {\n    var proto = target;\n    while (proto && !proto.hasOwnProperty(name)) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    if (!proto && target[name]) {\n        // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n        proto = target;\n    }\n    var delegateName = zoneSymbol(name);\n    var delegate;\n    if (proto && !(delegate = proto[delegateName])) {\n        delegate = proto[delegateName] = proto[name];\n        var patchDelegate_1 = patchFn(delegate, delegateName, name);\n        proto[name] = function () {\n            return patchDelegate_1(this, arguments);\n        };\n        attachOriginToPatched(proto[name], delegate);\n    }\n    return delegate;\n}\n// TODO: @JiaLiPassion, support cancel task later if necessary\n\n\nfunction findEventTask(target, evtName) {\n    var eventTasks = target[zoneSymbol('eventTasks')];\n    var result = [];\n    if (eventTasks) {\n        for (var i = 0; i < eventTasks.length; i++) {\n            var eventTask = eventTasks[i];\n            var data = eventTask.data;\n            var eventName = data && data.eventName;\n            if (eventName === evtName) {\n                result.push(eventTask);\n            }\n        }\n    }\n    return result;\n}\nfunction attachOriginToPatched(patched, original) {\n    patched[zoneSymbol('OriginalDelegate')] = original;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// override Function.prototype.toString to make zone.js patched function\n// look like native function\nZone.__load_patch('toString', function (global, Zone, api) {\n    // patch Func.prototype.toString to let them look like native\n    var originalFunctionToString = Function.prototype.toString;\n    Function.prototype.toString = function () {\n        if (typeof this === 'function') {\n            if (this[zoneSymbol('OriginalDelegate')]) {\n                return originalFunctionToString.apply(this[zoneSymbol('OriginalDelegate')], arguments);\n            }\n            if (this === Promise) {\n                var nativePromise = global[zoneSymbol('Promise')];\n                if (nativePromise) {\n                    return originalFunctionToString.apply(nativePromise, arguments);\n                }\n            }\n            if (this === Error) {\n                var nativeError = global[zoneSymbol('Error')];\n                if (nativeError) {\n                    return originalFunctionToString.apply(nativeError, arguments);\n                }\n            }\n        }\n        return originalFunctionToString.apply(this, arguments);\n    };\n    // patch Object.prototype.toString to let them look like native\n    var originalObjectToString = Object.prototype.toString;\n    Object.prototype.toString = function () {\n        if (this instanceof Promise) {\n            return '[object Promise]';\n        }\n        return originalObjectToString.apply(this, arguments);\n    };\n});\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction patchTimer(window, setName, cancelName, nameSuffix) {\n    var setNative = null;\n    var clearNative = null;\n    setName += nameSuffix;\n    cancelName += nameSuffix;\n    var tasksByHandleId = {};\n    function scheduleTask(task) {\n        var data = task.data;\n        function timer() {\n            try {\n                task.invoke.apply(this, arguments);\n            }\n            finally {\n                if (typeof data.handleId === 'number') {\n                    // Node returns complex objects as handleIds\n                    delete tasksByHandleId[data.handleId];\n                }\n            }\n        }\n        data.args[0] = timer;\n        data.handleId = setNative.apply(window, data.args);\n        if (typeof data.handleId === 'number') {\n            // Node returns complex objects as handleIds -> no need to keep them around. Additionally,\n            // this throws an\n            // exception in older node versions and has no effect there, because of the stringified key.\n            tasksByHandleId[data.handleId] = task;\n        }\n        return task;\n    }\n    function clearTask(task) {\n        if (typeof task.data.handleId === 'number') {\n            // Node returns complex objects as handleIds\n            delete tasksByHandleId[task.data.handleId];\n        }\n        return clearNative(task.data.handleId);\n    }\n    setNative =\n        patchMethod(window, setName, function (delegate) { return function (self, args) {\n            if (typeof args[0] === 'function') {\n                var zone = Zone.current;\n                var options = {\n                    handleId: null,\n                    isPeriodic: nameSuffix === 'Interval',\n                    delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 : null,\n                    args: args\n                };\n                var task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);\n                if (!task) {\n                    return task;\n                }\n                // Node.js must additionally support the ref and unref functions.\n                var handle = task.data.handleId;\n                // check whether handle is null, because some polyfill or browser\n                // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame\n                if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' &&\n                    typeof handle.unref === 'function') {\n                    task.ref = handle.ref.bind(handle);\n                    task.unref = handle.unref.bind(handle);\n                }\n                return task;\n            }\n            else {\n                // cause an error by calling it directly.\n                return delegate.apply(window, args);\n            }\n        }; });\n    clearNative =\n        patchMethod(window, cancelName, function (delegate) { return function (self, args) {\n            var task = typeof args[0] === 'number' ? tasksByHandleId[args[0]] : args[0];\n            if (task && typeof task.type === 'string') {\n                if (task.state !== 'notScheduled' &&\n                    (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {\n                    // Do not cancel already canceled functions\n                    task.zone.cancelTask(task);\n                }\n            }\n            else {\n                // cause an error by calling it directly.\n                delegate.apply(window, args);\n            }\n        }; });\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/*\n * This is necessary for Chrome and Chrome mobile, to enable\n * things like redefining `createdCallback` on an element.\n */\nvar _defineProperty = Object[zoneSymbol('defineProperty')] = Object.defineProperty;\nvar _getOwnPropertyDescriptor = Object[zoneSymbol('getOwnPropertyDescriptor')] =\n    Object.getOwnPropertyDescriptor;\nvar _create = Object.create;\nvar unconfigurablesKey = zoneSymbol('unconfigurables');\nfunction propertyPatch() {\n    Object.defineProperty = function (obj, prop, desc) {\n        if (isUnconfigurable(obj, prop)) {\n            throw new TypeError('Cannot assign to read only property \\'' + prop + '\\' of ' + obj);\n        }\n        var originalConfigurableFlag = desc.configurable;\n        if (prop !== 'prototype') {\n            desc = rewriteDescriptor(obj, prop, desc);\n        }\n        return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n    };\n    Object.defineProperties = function (obj, props) {\n        Object.keys(props).forEach(function (prop) {\n            Object.defineProperty(obj, prop, props[prop]);\n        });\n        return obj;\n    };\n    Object.create = function (obj, proto) {\n        if (typeof proto === 'object' && !Object.isFrozen(proto)) {\n            Object.keys(proto).forEach(function (prop) {\n                proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);\n            });\n        }\n        return _create(obj, proto);\n    };\n    Object.getOwnPropertyDescriptor = function (obj, prop) {\n        var desc = _getOwnPropertyDescriptor(obj, prop);\n        if (isUnconfigurable(obj, prop)) {\n            desc.configurable = false;\n        }\n        return desc;\n    };\n}\nfunction _redefineProperty(obj, prop, desc) {\n    var originalConfigurableFlag = desc.configurable;\n    desc = rewriteDescriptor(obj, prop, desc);\n    return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n}\nfunction isUnconfigurable(obj, prop) {\n    return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];\n}\nfunction rewriteDescriptor(obj, prop, desc) {\n    desc.configurable = true;\n    if (!desc.configurable) {\n        if (!obj[unconfigurablesKey]) {\n            _defineProperty(obj, unconfigurablesKey, { writable: true, value: {} });\n        }\n        obj[unconfigurablesKey][prop] = true;\n    }\n    return desc;\n}\nfunction _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {\n    try {\n        return _defineProperty(obj, prop, desc);\n    }\n    catch (error) {\n        if (desc.configurable) {\n            // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let's\n            // retry with the original flag value\n            if (typeof originalConfigurableFlag == 'undefined') {\n                delete desc.configurable;\n            }\n            else {\n                desc.configurable = originalConfigurableFlag;\n            }\n            try {\n                return _defineProperty(obj, prop, desc);\n            }\n            catch (error) {\n                var descJson = null;\n                try {\n                    descJson = JSON.stringify(desc);\n                }\n                catch (error) {\n                    descJson = descJson.toString();\n                }\n                console.log(\"Attempting to configure '\" + prop + \"' with descriptor '\" + descJson + \"' on object '\" + obj + \"' and got error, giving up: \" + error);\n            }\n        }\n        else {\n            throw error;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar WTF_ISSUE_555 = 'Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video';\nvar NO_EVENT_TARGET = 'ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket'\n    .split(',');\nvar EVENT_TARGET = 'EventTarget';\nfunction eventTargetPatch(_global) {\n    var apis = [];\n    var isWtf = _global['wtf'];\n    if (isWtf) {\n        // Workaround for: https://github.com/google/tracing-framework/issues/555\n        apis = WTF_ISSUE_555.split(',').map(function (v) { return 'HTML' + v + 'Element'; }).concat(NO_EVENT_TARGET);\n    }\n    else if (_global[EVENT_TARGET]) {\n        apis.push(EVENT_TARGET);\n    }\n    else {\n        // Note: EventTarget is not available in all browsers,\n        // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget\n        apis = NO_EVENT_TARGET;\n    }\n    for (var i = 0; i < apis.length; i++) {\n        var type = _global[apis[i]];\n        patchEventTargetMethods(type && type.prototype);\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// we have to patch the instance since the proto is non-configurable\nfunction apply(_global) {\n    var WS = _global.WebSocket;\n    // On Safari window.EventTarget doesn't exist so need to patch WS add/removeEventListener\n    // On older Chrome, no need since EventTarget was already patched\n    if (!_global.EventTarget) {\n        patchEventTargetMethods(WS.prototype);\n    }\n    _global.WebSocket = function (a, b) {\n        var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);\n        var proxySocket;\n        // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance\n        var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');\n        if (onmessageDesc && onmessageDesc.configurable === false) {\n            proxySocket = Object.create(socket);\n            ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function (propName) {\n                proxySocket[propName] = function () {\n                    return socket[propName].apply(socket, arguments);\n                };\n            });\n        }\n        else {\n            // we can patch the real socket\n            proxySocket = socket;\n        }\n        patchOnProperties(proxySocket, ['close', 'error', 'message', 'open']);\n        return proxySocket;\n    };\n    for (var prop in WS) {\n        _global['WebSocket'][prop] = WS[prop];\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar globalEventHandlersEventNames = [\n    'abort',\n    'animationcancel',\n    'animationend',\n    'animationiteration',\n    'auxclick',\n    'beforeinput',\n    'blur',\n    'cancel',\n    'canplay',\n    'canplaythrough',\n    'change',\n    'compositionstart',\n    'compositionupdate',\n    'compositionend',\n    'cuechange',\n    'click',\n    'close',\n    'contextmenu',\n    'curechange',\n    'dblclick',\n    'drag',\n    'dragend',\n    'dragenter',\n    'dragexit',\n    'dragleave',\n    'dragover',\n    'drop',\n    'durationchange',\n    'emptied',\n    'ended',\n    'error',\n    'focus',\n    'focusin',\n    'focusout',\n    'gotpointercapture',\n    'input',\n    'invalid',\n    'keydown',\n    'keypress',\n    'keyup',\n    'load',\n    'loadstart',\n    'loadeddata',\n    'loadedmetadata',\n    'lostpointercapture',\n    'mousedown',\n    'mouseenter',\n    'mouseleave',\n    'mousemove',\n    'mouseout',\n    'mouseover',\n    'mouseup',\n    'mousewheel',\n    'pause',\n    'play',\n    'playing',\n    'pointercancel',\n    'pointerdown',\n    'pointerenter',\n    'pointerleave',\n    'pointerlockchange',\n    'mozpointerlockchange',\n    'webkitpointerlockerchange',\n    'pointerlockerror',\n    'mozpointerlockerror',\n    'webkitpointerlockerror',\n    'pointermove',\n    'pointout',\n    'pointerover',\n    'pointerup',\n    'progress',\n    'ratechange',\n    'reset',\n    'resize',\n    'scroll',\n    'seeked',\n    'seeking',\n    'select',\n    'selectionchange',\n    'selectstart',\n    'show',\n    'sort',\n    'stalled',\n    'submit',\n    'suspend',\n    'timeupdate',\n    'volumechange',\n    'touchcancel',\n    'touchmove',\n    'touchstart',\n    'transitioncancel',\n    'transitionend',\n    'waiting',\n    'wheel'\n];\nvar documentEventNames = [\n    'afterscriptexecute', 'beforescriptexecute', 'DOMContentLoaded', 'fullscreenchange',\n    'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange', 'fullscreenerror',\n    'mozfullscreenerror', 'webkitfullscreenerror', 'msfullscreenerror', 'readystatechange'\n];\nvar windowEventNames = [\n    'absolutedeviceorientation',\n    'afterinput',\n    'afterprint',\n    'appinstalled',\n    'beforeinstallprompt',\n    'beforeprint',\n    'beforeunload',\n    'devicelight',\n    'devicemotion',\n    'deviceorientation',\n    'deviceorientationabsolute',\n    'deviceproximity',\n    'hashchange',\n    'languagechange',\n    'message',\n    'mozbeforepaint',\n    'offline',\n    'online',\n    'paint',\n    'pageshow',\n    'pagehide',\n    'popstate',\n    'rejectionhandled',\n    'storage',\n    'unhandledrejection',\n    'unload',\n    'userproximity',\n    'vrdisplyconnected',\n    'vrdisplaydisconnected',\n    'vrdisplaypresentchange'\n];\nvar htmlElementEventNames = [\n    'beforecopy', 'beforecut', 'beforepaste', 'copy', 'cut', 'paste', 'dragstart', 'loadend',\n    'animationstart', 'search', 'transitionrun', 'transitionstart', 'webkitanimationend',\n    'webkitanimationiteration', 'webkitanimationstart', 'webkittransitionend'\n];\nvar mediaElementEventNames = ['encrypted', 'waitingforkey', 'msneedkey', 'mozinterruptbegin', 'mozinterruptend'];\nvar ieElementEventNames = [\n    'activate',\n    'afterupdate',\n    'ariarequest',\n    'beforeactivate',\n    'beforedeactivate',\n    'beforeeditfocus',\n    'beforeupdate',\n    'cellchange',\n    'controlselect',\n    'dataavailable',\n    'datasetchanged',\n    'datasetcomplete',\n    'errorupdate',\n    'filterchange',\n    'layoutcomplete',\n    'losecapture',\n    'move',\n    'moveend',\n    'movestart',\n    'propertychange',\n    'resizeend',\n    'resizestart',\n    'rowenter',\n    'rowexit',\n    'rowsdelete',\n    'rowsinserted',\n    'command',\n    'compassneedscalibration',\n    'deactivate',\n    'help',\n    'mscontentzoom',\n    'msmanipulationstatechanged',\n    'msgesturechange',\n    'msgesturedoubletap',\n    'msgestureend',\n    'msgesturehold',\n    'msgesturestart',\n    'msgesturetap',\n    'msgotpointercapture',\n    'msinertiastart',\n    'mslostpointercapture',\n    'mspointercancel',\n    'mspointerdown',\n    'mspointerenter',\n    'mspointerhover',\n    'mspointerleave',\n    'mspointermove',\n    'mspointerout',\n    'mspointerover',\n    'mspointerup',\n    'pointerout',\n    'mssitemodejumplistitemremoved',\n    'msthumbnailclick',\n    'stop',\n    'storagecommit'\n];\nvar webglEventNames = ['webglcontextrestored', 'webglcontextlost', 'webglcontextcreationerror'];\nvar formEventNames = ['autocomplete', 'autocompleteerror'];\nvar detailEventNames = ['toggle'];\nvar frameEventNames = ['load'];\nvar frameSetEventNames = ['blur', 'error', 'focus', 'load', 'resize', 'scroll'];\nvar marqueeEventNames = ['bounce', 'finish', 'start'];\nvar XMLHttpRequestEventNames = [\n    'loadstart', 'progress', 'abort', 'error', 'load', 'progress', 'timeout', 'loadend',\n    'readystatechange'\n];\nvar IDBIndexEventNames = ['upgradeneeded', 'complete', 'abort', 'success', 'error', 'blocked', 'versionchange', 'close'];\nvar websocketEventNames = ['close', 'error', 'open', 'message'];\nvar eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);\nfunction propertyDescriptorPatch(_global) {\n    if (isNode && !isMix) {\n        return;\n    }\n    var supportsWebSocket = typeof WebSocket !== 'undefined';\n    if (canPatchViaPropertyDescriptor()) {\n        // for browsers that we can patch the descriptor:  Chrome & Firefox\n        if (isBrowser) {\n            // in IE/Edge, onProp not exist in window object, but in WindowPrototype\n            // so we need to pass WindowPrototype to check onProp exist or not\n            patchOnProperties(window, eventNames, Object.getPrototypeOf(window));\n            patchOnProperties(Document.prototype, eventNames);\n            if (typeof window['SVGElement'] !== 'undefined') {\n                patchOnProperties(window['SVGElement'].prototype, eventNames);\n            }\n            patchOnProperties(Element.prototype, eventNames);\n            patchOnProperties(HTMLElement.prototype, eventNames);\n            patchOnProperties(HTMLMediaElement.prototype, mediaElementEventNames);\n            patchOnProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames));\n            patchOnProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames));\n            patchOnProperties(HTMLFrameElement.prototype, frameEventNames);\n            patchOnProperties(HTMLIFrameElement.prototype, frameEventNames);\n            var HTMLMarqueeElement_1 = window['HTMLMarqueeElement'];\n            if (HTMLMarqueeElement_1) {\n                patchOnProperties(HTMLMarqueeElement_1.prototype, marqueeEventNames);\n            }\n        }\n        patchOnProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames);\n        var XMLHttpRequestEventTarget = _global['XMLHttpRequestEventTarget'];\n        if (XMLHttpRequestEventTarget) {\n            patchOnProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames);\n        }\n        if (typeof IDBIndex !== 'undefined') {\n            patchOnProperties(IDBIndex.prototype, IDBIndexEventNames);\n            patchOnProperties(IDBRequest.prototype, IDBIndexEventNames);\n            patchOnProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames);\n            patchOnProperties(IDBDatabase.prototype, IDBIndexEventNames);\n            patchOnProperties(IDBTransaction.prototype, IDBIndexEventNames);\n            patchOnProperties(IDBCursor.prototype, IDBIndexEventNames);\n        }\n        if (supportsWebSocket) {\n            patchOnProperties(WebSocket.prototype, websocketEventNames);\n        }\n    }\n    else {\n        // Safari, Android browsers (Jelly Bean)\n        patchViaCapturingAllTheEvents();\n        patchClass('XMLHttpRequest');\n        if (supportsWebSocket) {\n            apply(_global);\n        }\n    }\n}\nfunction canPatchViaPropertyDescriptor() {\n    if ((isBrowser || isMix) && !Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') &&\n        typeof Element !== 'undefined') {\n        // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364\n        // IDL interface attributes are not configurable\n        var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');\n        if (desc && !desc.configurable)\n            return false;\n    }\n    var xhrDesc = Object.getOwnPropertyDescriptor(XMLHttpRequest.prototype, 'onreadystatechange');\n    // add enumerable and configurable here because in opera\n    // by default XMLHttpRequest.prototype.onreadystatechange is undefined\n    // without adding enumerable and configurable will cause onreadystatechange\n    // non-configurable\n    // and if XMLHttpRequest.prototype.onreadystatechange is undefined,\n    // we should set a real desc instead a fake one\n    if (xhrDesc) {\n        Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n                return true;\n            }\n        });\n        var req = new XMLHttpRequest();\n        var result = !!req.onreadystatechange;\n        // restore original desc\n        Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', xhrDesc || {});\n        return result;\n    }\n    else {\n        Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n                return this[zoneSymbol('fakeonreadystatechange')];\n            },\n            set: function (value) {\n                this[zoneSymbol('fakeonreadystatechange')] = value;\n            }\n        });\n        var req = new XMLHttpRequest();\n        var detectFunc = function () { };\n        req.onreadystatechange = detectFunc;\n        var result = req[zoneSymbol('fakeonreadystatechange')] === detectFunc;\n        req.onreadystatechange = null;\n        return result;\n    }\n}\n\nvar unboundKey = zoneSymbol('unbound');\n// Whenever any eventListener fires, we check the eventListener target and all parents\n// for `onwhatever` properties and replace them with zone-bound functions\n// - Chrome (for now)\nfunction patchViaCapturingAllTheEvents() {\n    var _loop_1 = function (i) {\n        var property = eventNames[i];\n        var onproperty = 'on' + property;\n        self.addEventListener(property, function (event) {\n            var elt = event.target, bound, source;\n            if (elt) {\n                source = elt.constructor['name'] + '.' + onproperty;\n            }\n            else {\n                source = 'unknown.' + onproperty;\n            }\n            while (elt) {\n                if (elt[onproperty] && !elt[onproperty][unboundKey]) {\n                    bound = Zone.current.wrap(elt[onproperty], source);\n                    bound[unboundKey] = elt[onproperty];\n                    elt[onproperty] = bound;\n                }\n                elt = elt.parentElement;\n            }\n        }, true);\n    };\n    for (var i = 0; i < eventNames.length; i++) {\n        _loop_1(i);\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction registerElementPatch(_global) {\n    if ((!isBrowser && !isMix) || !('registerElement' in _global.document)) {\n        return;\n    }\n    var _registerElement = document.registerElement;\n    var callbacks = ['createdCallback', 'attachedCallback', 'detachedCallback', 'attributeChangedCallback'];\n    document.registerElement = function (name, opts) {\n        if (opts && opts.prototype) {\n            callbacks.forEach(function (callback) {\n                var source = 'Document.registerElement::' + callback;\n                if (opts.prototype.hasOwnProperty(callback)) {\n                    var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);\n                    if (descriptor && descriptor.value) {\n                        descriptor.value = Zone.current.wrap(descriptor.value, source);\n                        _redefineProperty(opts.prototype, callback, descriptor);\n                    }\n                    else {\n                        opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);\n                    }\n                }\n                else if (opts.prototype[callback]) {\n                    opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);\n                }\n            });\n        }\n        return _registerElement.apply(document, [name, opts]);\n    };\n    attachOriginToPatched(document.registerElement, _registerElement);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('timers', function (global, Zone, api) {\n    var set = 'set';\n    var clear = 'clear';\n    patchTimer(global, set, clear, 'Timeout');\n    patchTimer(global, set, clear, 'Interval');\n    patchTimer(global, set, clear, 'Immediate');\n    patchTimer(global, 'request', 'cancel', 'AnimationFrame');\n    patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');\n    patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');\n});\nZone.__load_patch('blocking', function (global, Zone, api) {\n    var blockingMethods = ['alert', 'prompt', 'confirm'];\n    for (var i = 0; i < blockingMethods.length; i++) {\n        var name_1 = blockingMethods[i];\n        patchMethod(global, name_1, function (delegate, symbol, name) {\n            return function (s, args) {\n                return Zone.current.run(delegate, global, args, name);\n            };\n        });\n    }\n});\nZone.__load_patch('EventTarget', function (global, Zone, api) {\n    eventTargetPatch(global);\n    // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener\n    var XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];\n    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\n        patchEventTargetMethods(XMLHttpRequestEventTarget.prototype);\n    }\n    patchClass('MutationObserver');\n    patchClass('WebKitMutationObserver');\n    patchClass('FileReader');\n});\nZone.__load_patch('on_property', function (global, Zone, api) {\n    propertyDescriptorPatch(global);\n    propertyPatch();\n    registerElementPatch(global);\n});\nZone.__load_patch('XHR', function (global, Zone, api) {\n    // Treat XMLHTTPRequest as a macrotask.\n    patchXHR(global);\n    var XHR_TASK = zoneSymbol('xhrTask');\n    var XHR_SYNC = zoneSymbol('xhrSync');\n    var XHR_LISTENER = zoneSymbol('xhrListener');\n    var XHR_SCHEDULED = zoneSymbol('xhrScheduled');\n    function patchXHR(window) {\n        function findPendingTask(target) {\n            var pendingTask = target[XHR_TASK];\n            return pendingTask;\n        }\n        function scheduleTask(task) {\n            XMLHttpRequest[XHR_SCHEDULED] = false;\n            var data = task.data;\n            // remove existing event listener\n            var listener = data.target[XHR_LISTENER];\n            if (listener) {\n                data.target.removeEventListener('readystatechange', listener);\n            }\n            var newListener = data.target[XHR_LISTENER] = function () {\n                if (data.target.readyState === data.target.DONE) {\n                    // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with\n                    // readyState=4 multiple times, so we need to check task state here\n                    if (!data.aborted && XMLHttpRequest[XHR_SCHEDULED] &&\n                        task.state === 'scheduled') {\n                        task.invoke();\n                    }\n                }\n            };\n            data.target.addEventListener('readystatechange', newListener);\n            var storedTask = data.target[XHR_TASK];\n            if (!storedTask) {\n                data.target[XHR_TASK] = task;\n            }\n            sendNative.apply(data.target, data.args);\n            XMLHttpRequest[XHR_SCHEDULED] = true;\n            return task;\n        }\n        function placeholderCallback() { }\n        function clearTask(task) {\n            var data = task.data;\n            // Note - ideally, we would call data.target.removeEventListener here, but it's too late\n            // to prevent it from firing. So instead, we store info for the event listener.\n            data.aborted = true;\n            return abortNative.apply(data.target, data.args);\n        }\n        var openNative = patchMethod(window.XMLHttpRequest.prototype, 'open', function () { return function (self, args) {\n            self[XHR_SYNC] = args[2] == false;\n            return openNative.apply(self, args);\n        }; });\n        var sendNative = patchMethod(window.XMLHttpRequest.prototype, 'send', function () { return function (self, args) {\n            var zone = Zone.current;\n            if (self[XHR_SYNC]) {\n                // if the XHR is sync there is no task to schedule, just execute the code.\n                return sendNative.apply(self, args);\n            }\n            else {\n                var options = { target: self, isPeriodic: false, delay: null, args: args, aborted: false };\n                return zone.scheduleMacroTask('XMLHttpRequest.send', placeholderCallback, options, scheduleTask, clearTask);\n            }\n        }; });\n        var abortNative = patchMethod(window.XMLHttpRequest.prototype, 'abort', function (delegate) { return function (self, args) {\n            var task = findPendingTask(self);\n            if (task && typeof task.type == 'string') {\n                // If the XHR has already completed, do nothing.\n                // If the XHR has already been aborted, do nothing.\n                // Fix #569, call abort multiple times before done will cause\n                // macroTask task count be negative number\n                if (task.cancelFn == null || (task.data && task.data.aborted)) {\n                    return;\n                }\n                task.zone.cancelTask(task);\n            }\n            // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no\n            // task\n            // to cancel. Do nothing.\n        }; });\n    }\n});\nZone.__load_patch('geolocation', function (global, Zone, api) {\n    /// GEO_LOCATION\n    if (global['navigator'] && global['navigator'].geolocation) {\n        patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);\n    }\n});\nZone.__load_patch('PromiseRejectionEvent', function (global, Zone, api) {\n    // handle unhandled promise rejection\n    function findPromiseRejectionHandler(evtName) {\n        return function (e) {\n            var eventTasks = findEventTask(global, evtName);\n            eventTasks.forEach(function (eventTask) {\n                // windows has added unhandledrejection event listener\n                // trigger the event listener\n                var PromiseRejectionEvent = global['PromiseRejectionEvent'];\n                if (PromiseRejectionEvent) {\n                    var evt = new PromiseRejectionEvent(evtName, { promise: e.promise, reason: e.rejection });\n                    eventTask.invoke(evt);\n                }\n            });\n        };\n    }\n    if (global['PromiseRejectionEvent']) {\n        Zone[zoneSymbol('unhandledPromiseRejectionHandler')] =\n            findPromiseRejectionHandler('unhandledrejection');\n        Zone[zoneSymbol('rejectionHandledHandler')] =\n            findPromiseRejectionHandler('rejectionhandled');\n    }\n});\nZone.__load_patch('util', function (global, Zone, api) {\n    api.patchEventTargetMethods = patchEventTargetMethods;\n    api.patchOnProperties = patchOnProperties;\n});\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zone.js/dist/zone.js\n// module id = ./node_modules/zone.js/dist/zone.js\n// module chunks = 1","/* tslint:disable */\nimport \"reflect-metadata/Reflect\";\nimport \"zone.js/dist/zone\";\n\nrequire('../manifest.webapp');\n\n\n\n// WEBPACK FOOTER //\n// ./src/main/webapp/app/polyfills.ts","module.exports = __webpack_public_path__ + \"manifest.webapp\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/main/webapp/manifest.webapp\n// module id = ./src/main/webapp/manifest.webapp\n// module chunks = 1","module.exports = vendor;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"vendor\"\n// module id = 1\n// module chunks = 1","module.exports = (__webpack_require__(1))(36);\n\n\n//////////////////\n// WEBPACK FOOTER\n// delegated ./node_modules/webpack/buildin/global.js from dll-reference vendor\n// module id = 16\n// module chunks = 1","module.exports = (__webpack_require__(1))(263);\n\n\n//////////////////\n// WEBPACK FOOTER\n// delegated ./node_modules/process/browser.js from dll-reference vendor\n// module id = 24\n// module chunks = 1","module.exports = (__webpack_require__(1))(27);\n\n\n//////////////////\n// WEBPACK FOOTER\n// delegated ./node_modules/css-loader/lib/css-base.js from dll-reference vendor\n// module id = 8\n// module chunks = 1"],"sourceRoot":""}